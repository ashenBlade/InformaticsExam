# Вопросы по информатике

## Содержание

- [Вопросы по информатике](#вопросы-по-информатике)
  - [Содержание](#содержание)
  - [Введение в ASP.NET Core](#введение-в-aspnet-core)
    - [Понятие фреймворка](#понятие-фреймворка)
    - [Особенности фреймворков](#особенности-фреймворков)
    - [ASP.NET Core](#aspnet-core)
    - [Свойство кросс-платформенности. Преимущества](#свойство-кросс-платформенности-преимущества)
    - [Запуск и настройка приложения](#запуск-и-настройка-приложения)
    - [Запуск](#запуск)
    - [Паттерн Builder](#паттерн-builder)
    - [Program и StartUp, как с этим в .NET 6](#program-и-startup-как-с-этим-в-net-6)
    - [HostBuilder. WebApplicationBuilder](#hostbuilder-webapplicationbuilder)
    - [Content & Web root path](#content--web-root-path)
    - [Окружения](#окружения)
    - [launchSettings.json](#launchsettingsjson)
    - [Класс Startup (.NET Core 3.x/5)](#класс-startup-net-core-3x5)
    - [Настройка приложения в .NET 6](#настройка-приложения-в-net-6)
    - [Dependency Inversion Principle](#dependency-inversion-principle)
    - [Сервисы](#сервисы)
    - [Инъекция зависимостей (зачем)](#инъекция-зависимостей-зачем)
    - [IoC контейнеры](#ioc-контейнеры)
    - [Инъекция в Startup (.NET Core 3.x/5)](#инъекция-в-startup-net-core-3x5)
    - [Замена контейнера. Замена на autofac](#замена-контейнера-замена-на-autofac)
    - [Доступ к сервисам](#доступ-к-сервисам)
    - [Middleware](#middleware)
    - [Методы Use и Run](#методы-use-и-run)
    - [Методы Map и MapWhen](#методы-map-и-mapwhen)
    - [Создание компонент middleware](#создание-компонент-middleware)
    - [Статические файлы](#статические-файлы)
    - [Конвейер обработки запроса](#конвейер-обработки-запроса)
    - [Время жизни middleware](#время-жизни-middleware)
    - [Ведение журнала](#ведение-журнала)
    - [Обработка ошибок](#обработка-ошибок)
    - [Публикация в Azure](#публикация-в-azure)
  - [ASP.NET Core. Publish & Deploy](#aspnet-core-publish--deploy)
    - [Модель хостинга ASP.NET Core](#модель-хостинга-aspnet-core)
    - [Reverse proxy](#reverse-proxy)
    - [Run ASP.NET Core app](#run-aspnet-core-app)
    - [Публикация](#публикация)
    - [Запуск опубликованного приложения](#запуск-опубликованного-приложения)
    - [dotnet command](#dotnet-command)
    - [Независимый деплой](#независимый-деплой)
    - [Как деплоить](#как-деплоить)
    - [CI/CD](#cicd)
    - [Развёртывание в IIS](#развёртывание-в-iis)
    - [Пул приложений](#пул-приложений)
    - [Поддержка в коде. Middleware](#поддержка-в-коде-middleware)
    - [web.config](#webconfig)
    - [Хостинг приложений под Linux](#хостинг-приложений-под-linux)
    - [Run ASP.NET Core app on Linux](#run-aspnet-core-app-on-linux)
    - [ASP.NET Core in Docker](#aspnet-core-in-docker)
    - [Docker](#docker)
    - [Потенциальные проблемы при деплое](#потенциальные-проблемы-при-деплое)
    - [Разница между Linux и Windows](#разница-между-linux-и-windows)
    - [Конфигурирование](#конфигурирование)
    - [Бандлинг/минификация](#бандлингминификация)
  - [ASP.NET Core. Middleware](#aspnet-core-middleware)
    - [Обработка запроса](#обработка-запроса)
    - [HttpContext](#httpcontext)
    - [HttpRequest](#httprequest)
    - [HttpResponse](#httpresponse)
    - [Middleware](#middleware-1)
    - [Примеры](#примеры)
    - [Middleware Pipeline](#middleware-pipeline)
    - [Выстраивание конвейера](#выстраивание-конвейера)
    - [Методы Use, Map, Run, MapWhen](#методы-use-map-run-mapwhen)
    - [Проблема с формированием ответа](#проблема-с-формированием-ответа)
    - [Кастомные компоненты Middleware](#кастомные-компоненты-middleware)
    - [Дополнительные параметры](#дополнительные-параметры)
    - [Порядок вызова](#порядок-вызова)
    - [Middleware обработки ошибок](#middleware-обработки-ошибок)
    - [Middleware vs Services](#middleware-vs-services)
    - [Маршрутизация в ASP.NET Core](#маршрутизация-в-aspnet-core)
    - [Конечные точки](#конечные-точки)
    - [Шаблоны маршрутов](#шаблоны-маршрутов)
    - [Маршрутизация - Концепции](#маршрутизация---концепции)
    - [Совпадение маршрутов](#совпадение-маршрутов)
    - [Генерация URL-адресов](#генерация-url-адресов)
    - [Обработка ошибок](#обработка-ошибок-1)
    - [Обработка ошибок HTTP: UseStatusCodePagesWithRedirects vs UseStatusCodePagesWithReExecute](#обработка-ошибок-http-usestatuscodepageswithredirects-vs-usestatuscodepageswithreexecute)
    - [Использование Cookie](#использование-cookie)
    - [Сессии](#сессии)
  - [ASP.NET Core. Services & DI](#aspnet-core-services--di)
    - [Сервисы - зависимости](#сервисы---зависимости)
    - [Пример зависимости](#пример-зависимости)
    - [Проблемы прямых зависимостей](#проблемы-прямых-зависимостей)
    - [S.O.L.I.D](#solid)
    - [ServiceLocator](#servicelocator)
    - [DI анти-паттерны](#di-анти-паттерны)
    - [IoC (Inversion of Control)](#ioc-inversion-of-control)
    - [Свой тривиальный контейнер](#свой-тривиальный-контейнер)
    - [IServiceProvider](#iserviceprovider)
    - [Регистрация сервисов](#регистрация-сервисов)
    - [IServiceCollection Extension methods](#iservicecollection-extension-methods)
    - [Время жизни](#время-жизни)
    - [Варианты регистрации](#варианты-регистрации)
    - [Общая схема работы](#общая-схема-работы)
    - [Типичные ошибки с Lifetime](#типичные-ошибки-с-lifetime)
    - [Резолв из transient сервиса scoped или singleton зависимостей](#резолв-из-transient-сервиса-scoped-или-singleton-зависимостей)
    - [GetService\<TService\>()](#getservicetservice)
    - [Несколько сервисов или интерфейсов](#несколько-сервисов-или-интерфейсов)
    - [Рекомендации по созданию сервисов](#рекомендации-по-созданию-сервисов)
    - [Disposal of services](#disposal-of-services)
    - [Рекомендации по использованию сервисов](#рекомендации-по-использованию-сервисов)
  - [Архитектура приложений ASP.NET Core MVC](#архитектура-приложений-aspnet-core-mvc)
    - [Монолитное приложение](#монолитное-приложение)
    - [All-in-one приложения](#all-in-one-приложения)
    - [Слои приложения](#слои-приложения)
    - [Правильные зависимости](#правильные-зависимости)
    - [Чистая архитектура](#чистая-архитектура)
    - [Распределение по слоям](#распределение-по-слоям)
    - [UI ASP.NET Core](#ui-aspnet-core)
    - [ASP.NET Core MVC / Razor Pages](#aspnet-core-mvc--razor-pages)
    - [Model / ViewModel](#model--viewmodel)
    - [Контроллеры](#контроллеры)
    - [Действия (action)](#действия-action)
    - [IActionResult](#iactionresult)
    - [IActionResult: redirect](#iactionresult-redirect)
    - [Валидация модели](#валидация-модели)
    - [Представления](#представления)
    - [Razor](#razor)
    - [Передача данных в представления](#передача-данных-в-представления)
    - [Вспомогательные функции тегов](#вспомогательные-функции-тегов)
    - [Скаффолдинг](#скаффолдинг)
    - [Маршрутизация](#маршрутизация)
    - [Атрибуты маршрутизации](#атрибуты-маршрутизации)
    - [ControllerContext](#controllercontext)
    - [Передача параметров в запросе](#передача-параметров-в-запросе)
    - [model binding, массивы/объекты](#model-binding-массивыобъекты)
    - [Загрузка файлов](#загрузка-файлов)
    - [Работа с файлами - Безопасность](#работа-с-файлами---безопасность)
    - [Инъекции зависимостей](#инъекции-зависимостей)
  - [ASP.NET Core Auth*](#aspnet-core-auth)
    - [Фильтры MVC](#фильтры-mvc)
    - [Виды фильтров](#виды-фильтров)
    - [Создание фильтров](#создание-фильтров)
    - [Добавление фильтров](#добавление-фильтров)
    - [Identification / Authentication / Authorization](#identification--authentication--authorization)
    - [Способы аутентификации](#способы-аутентификации)
    - [Аутентификация по паролю - Уязвимости](#аутентификация-по-паролю---уязвимости)
    - [Аутентификация по токенам](#аутентификация-по-токенам)
    - [Форматы токенов](#форматы-токенов)
    - [Аутентификация в ASP.NET Core](#аутентификация-в-aspnet-core)
    - [HttpContext.User](#httpcontextuser)
    - [ClaimsPrincipal](#claimsprincipal)
    - [Claims vs Roles approach](#claims-vs-roles-approach)
    - [Процесс аутентификации](#процесс-аутентификации)
    - [Middleware. Добавление в обработку](#middleware-добавление-в-обработку)
    - [Задачи аутентификации](#задачи-аутентификации)
    - [Схема аутентификации](#схема-аутентификации)
    - [Создание аутентификационной куки](#создание-аутентификационной-куки)
    - [Удадение и обновление куки](#удадение-и-обновление-куки)
    - [ASP.Net Core Identity](#aspnet-core-identity)
    - [Возможности Identity](#возможности-identity)
    - [Кастомизация Identity](#кастомизация-identity)
    - [Сервисы Identity](#сервисы-identity)
    - [Настройка Cookie для Identity](#настройка-cookie-для-identity)
    - [Identity’s database schema](#identitys-database-schema)
    - [Сервисы](#сервисы-1)
    - [Кастомизация пользователей](#кастомизация-пользователей)
    - [Кастомные claims](#кастомные-claims)
    - [Simple Authorization](#simple-authorization)
    - [Авторизация по ролям](#авторизация-по-ролям)
    - [Authorization Policy](#authorization-policy)
    - [Добавление политики авторизации](#добавление-политики-авторизации)
    - [Ограничения политик (методы)](#ограничения-политик-методы)
    - [RequireAssertion(handler)](#requireassertionhandler)
    - [Пример авторизации](#пример-авторизации)
    - [Пример своего ограничения](#пример-своего-ограничения)
    - [Использование контекста MVC.](#использование-контекста-mvc)
    - [Resource-based authorization](#resource-based-authorization)
  - [ASP.NET Core. Security](#aspnet-core-security)
    - [SSL](#ssl)
    - [Сертификаты](#сертификаты)
    - [Атака Open Redirect. Защита](#атака-open-redirect-защита)
    - [Защита данных](#защита-данных)
    - [Шифрование данных (CryptoAPI)](#шифрование-данных-cryptoapi)
    - [Установка времени жизни](#установка-времени-жизни)
    - [Хранение паролей](#хранение-паролей)
    - [Настройка криптографии](#настройка-криптографии)
    - [Клиентские уязвимости](#клиентские-уязвимости)
    - [Same-origin policy (SOP)](#same-origin-policy-sop)
    - [Что такое Origin](#что-такое-origin)
    - [Суть XSS. Пример](#суть-xss-пример)
    - [Как предотвратить инъекции](#как-предотвратить-инъекции)
    - [Валидация и фильтрация. Санитизация. Общие правила. Razor](#валидация-и-фильтрация-санитизация-общие-правила-razor)
    - [Content Security Policy (CSP)](#content-security-policy-csp)
    - [CSP Report Request](#csp-report-request)
    - [Тег base](#тег-base)
    - [X-XSS-Protection](#x-xss-protection)
    - [Cross-Site Request Forgery (CSRF)](#cross-site-request-forgery-csrf)
    - [Double-Submit Cookie Pattern. Валидация Anti Forgery Token](#double-submit-cookie-pattern-валидация-anti-forgery-token)
    - [Anti Forgery Token в AJAX, WebAPI, SPA](#anti-forgery-token-в-ajax-webapi-spa)
    - [Cross Origin Request Sharing (CORS)](#cross-origin-request-sharing-cors)
    - [Безопасность кук](#безопасность-кук)
    - [SQL-инъекции.](#sql-инъекции)
  - [REST. Web API.](#rest-web-api)
    - [Что такое web-сервисы](#что-такое-web-сервисы)
    - [Протоколы веб-сервисов](#протоколы-веб-сервисов)
    - [Преимущества REST](#преимущества-rest)
    - [Когда использовать REST](#когда-использовать-rest)
    - [Что такое RESTful](#что-такое-restful)
    - [Принципы единого интерфейса](#принципы-единого-интерфейса)
    - [HATEOAS с примером](#hateoas-с-примером)
    - [Реализация REST](#реализация-rest)
    - [Идемпотентность](#идемпотентность)
    - [HTTP методы](#http-методы)
    - [REST vs SOAP](#rest-vs-soap)
    - [Информирование потребителя](#информирование-потребителя)
    - [Безопасность – уязвимости](#безопасность--уязвимости)
    - [Безопасность – аутентификация](#безопасность--аутентификация)
    - [Алгоритм Token-Based](#алгоритм-token-based)
    - [Недостатки контроля доступа к объектам](#недостатки-контроля-доступа-к-объектам)
    - [Небезопасная десериализация](#небезопасная-десериализация)
    - [Отсутствие проверок и ограничений](#отсутствие-проверок-и-ограничений)
    - [Недостатки управления API](#недостатки-управления-api)
    - [REST API Best Practices](#rest-api-best-practices)
    - [Введение в Web API](#введение-в-web-api)
    - [Приложение](#приложение)
    - [Атрибуты](#атрибуты)
    - [Тестирование](#тестирование)
    - [Статусы](#статусы)
    - [Возвращаемое значение в ASP.NET Core](#возвращаемое-значение-в-aspnet-core)
    - [IActionResult](#iactionresult-1)
    - [Content negotiation](#content-negotiation)
    - [Accept](#accept)
    - [xml - возвращаемое значение](#xml---возвращаемое-значение)
    - [Аутентификация – JWT](#аутентификация--jwt)
    - [JWT – сервисы и конвеер](#jwt--сервисы-и-конвеер)
    - [JWT – генерация токена](#jwt--генерация-токена)
    - [Swagger / OpenAPI](#swagger--openapi)
    - [Обработка ошибок.](#обработка-ошибок-2)
  - [Микросервисная архитектура](#микросервисная-архитектура)
    - [Общее описание](#общее-описание)
    - [Сравнение с монолитом](#сравнение-с-монолитом)
    - [Проблемы монолита](#проблемы-монолита)
    - [Преимущества микросервисов](#преимущества-микросервисов)
    - [Принципы проектирования](#принципы-проектирования)
    - [Минусы микросервисной архитектуры](#минусы-микросервисной-архитектуры)
    - [Реализация архитектуры](#реализация-архитектуры)
    - [Взаимодействие микросервисов](#взаимодействие-микросервисов)
    - [Взаимодействие в .Net](#взаимодействие-в-net)
    - [Слабая связанность](#слабая-связанность)
    - [Отказоустойчивость](#отказоустойчивость)
    - [API Gateway](#api-gateway)
    - [Легкая заменяемость](#легкая-заменяемость)
    - [Наблюдаемость](#наблюдаемость)
    - [Health Check](#health-check)
    - [Логгирование](#логгирование)

## Введение в ASP.NET Core

### Понятие фреймворка

Фреймворк - карскас, определяющий структуру ПО. Облегчает разработку и объединение различных программных компонентов.
Диктует правила построения архитектуры приложения

### Особенности фреймворков

Библиотека, в отличие от фреймворка, предоставляет функциональность и не влияет на архитектуру.

### ASP.NET Core

ASP.NET Core - свободно-распространяемый кроссплатформенный фреймворк для создания веб-приложений на платформе .NET с открытым исходным кодом.
Построен на новом веб-стеке, но при этом обладает высокой степенью совместимости с ASP.NET.
Совмещает несколько моделей разработки: базовый (минимальные необходимые требования - middleware, routing, configuration), MVC, Razor Pages (надстройка над MVC), WebAPI, Blazor

### Свойство кросс-платформенности. Преимущества

Кросс-платформенность позволяет создавать WORA приложения (write once run anywhere). Мы можем написать общий код, описывающий общую функциональность, а затем запускать его на разных машинах, на разных ОС и т.д. Преимущества:

- Уменьшение времени разработки
- Сокращение расходов
- Единая кодовая база
- Покрытие более широкой аудитории
- Одинаковый UI/UX

### Запуск и настройка приложения

Приложение запускается из Main. Через метод статического класса WebApplicationBuilder.CreateBuilder() мы получаем объект WebApplicationBuilder, в котором определяем настройки нашего приложения: конфигурация, логирование, окружение, зависимости и т.д.

Когда настройка завершена, создаем само приложение, вызывая метод Build(). Полученный объект - наше приложение, которое и нужно запустить.

### Запуск

WebApplicationBuilder builder = WebApplication.CreateBuilder();
WebApplication app = builder.Build();

### Паттерн Builder

Builder - один из порождающих паттернов GoF. Позволяет создавать крупные составные объекты. Хорошо работает с FluentAPI.

Пример, когда есть значения по умолчанию, а нам нужно создать объект, в котором изменяется только 1 аргумент в конструкторе.

### Program и StartUp, как с этим в .NET 6

В .NET 6 убрали необходимость в отдельном классе StartUp. Его 2 основных метода теперь можно реализовать прямо в методе Main (начиная с C# 10 (вроде), метод Main не нужно явно реализовывать). Теперь все можно сделать в 1 методе - сначала ConfigureServices, затем Configure.

### HostBuilder. WebApplicationBuilder

HostBulider - **общий** класс для построения хостов.

WebApplicationBuilder - класс для постоения хостов преимущественно **HTTP(S)**.

В кратце, HostBuilder создает IHost (для любых подключений), WepHostBuilder создает IWebHost (для веб серверов). IHost может быть каким-нибудь клиентом Postgres (он http не принимает), IWebHost - наш веб-сервер. По умолчанию, в шаблоне Web используем IWebHost с WebHostBuilder.CreateBuilder(args)

### Content & Web root path

ContentRootPath - путь до файлов самого приложения (dll, exe)

WebRootPath - путь до файлов, обрабатываемых запросами (wwwroot по умолчанию)

Оба: абсолютные (с корня), задаются в IWebHostEnvironment, для каждого свой FileProvider

### Окружения

Нужны для корректной работы, передачи важных переменных (строки подключения, пароли, кол-во подключений в пуле и т.д.). Источники задаются в ConfigurationManager объекта IWebHostBuilder. 

Значения окружения могут быть получены из:

- файлов (launchSettings.json, web.config)
- переменных окружения (ASPNETCORE_URLS)
- задаваться вручную (AddInMemoryCollection(IEnumarable\<KeyValuePair\>))

### launchSettings.json

Настройки приложения могут быть получены из файла. По умолчанию в папке проекта ищется файл launchSettings.json, в котором в формате json определены настройки для проекта. 

Также в зависимости от типа кружения (Production, Developement ...) могут быть загружены специфичные настройки. Спец. настройки указываются в файле launchSettings.{Environment}.json (launchSettings.Development.json). Указанные в них значения перетирают launchSettings.json (если присутствуют)

### Класс Startup (.NET Core 3.x/5)

До .NET 6 для настройки сервисов и пайплайна обрабоки использовался класс специальный класс (StartUp по умолчанию), в котором должны быть опеределны 2 метода - ConfigureServices, Configure. В первом методе добавлялись сервисы необходимые для функционирования, во втором настраивался порядок обработки запроса (Pipeline).

### Настройка приложения в .NET 6

Начиная с .NET 6 необходимость в этом классе ушла и все необходимые манипуляции можно произвести в основном методе Main. Сначала создаем Builder, его настраиваем. Затем вызываем Build(), получаем  объект WepApplication. В нем настраиваем конвеер обработки (UseRouting, UseAuthorization...). В конце вызываем Run().

### Dependency Inversion Principle

Идея такая - вам нужен не сам класс, а его функциональность. Нам нужен не человек, а что-то, что может перетаскать коробки, а это могут быть робот, человек, магия и т.д. В таком случае, мы определяем ЧТО нам нужно, выделяем это ЧТО-ТО в отдельный интерфейс, и на основе этого делаем реализацию.

> Мы должны зависеть от абстракции, а не от реализации

### Сервисы

Сервис (англ. Service - обслуживать) - это что-то, что выполняет какую-то функциональность. Например, шлет email, логирует и т.д. 

Хорошо согласуется с [Dependency Inversion Principle](#dependency-inversion-principle) - в конструктор передаем выделенные интерфейсы.

### Инъекция зависимостей (зачем)

Инъекция зависимостей - паттерн, при котором мы передаем не сами классы с реализацией, а их интерфейсы (см. [Depency Inversion](#dependency-inversion-principle)). 

Зачем:

- динамчески заменять реализацию (в зависимости в от состояния подключения либо в памяти, либо в файл, либо в бд сохранять изменения)
- для тестов (заменяем на моки, стабы, фейки)

### IoC контейнеры

IoC container (IoC - Inversion of Control) - контейнер (объект) содержащий в себе все необходимые сущности. 
Сам выстраивает граф зависимостей для создания, определяет что нужно и т.д.
В ASP.NET Core из коробки есть свой, но можно заменить на другие (Autofac ...)

### Инъекция в Startup (.NET Core 3.x/5)

В .NET Core 3.x/5 должен быть метод StartUp, котором есть методы ConfigureServices, Configure 
(см. [Класс StartUp (.NET Core 3.x/5)](#класс-startup-net-core-3x5)). 
Иногда нам нужно определить в каком окружении мы исполняемся - тест или прод. 
В таком случае мы можем пробросить зависимости в конструктор (или сам метод (уточнить!)). 
Например, IWebHostEnvironment.

### Замена контейнера. Замена на autofac

Замена контейнера производится как обычная замена сервиса - только заменить дескриптор. 

Пример для Autofac:

```cs
var host = new WebHostBuilder()
        .UseKestrel()
        .ConfigureServices(services => services.AddAutofac()) // Здесь заменяем
        .UseContentRoot(Directory.GetCurrentDirectory())
        .UseIISIntegration()
        .UseStartup<Startup>()
        .Build();

    host.Run();
```

Замена работает и для общего хоста IHost:

```cs
var host = Host.CreateDefaultBuilder(args)
        .UseServiceProviderFactory(new AutofacServiceProviderFactory())
        .ConfigureWebHostDefaults(webHostBuilder => {
          webHostBuilder
            .UseContentRoot(Directory.GetCurrentDirectory())
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
```

### Доступ к сервисам

Доступ к сервисам происходит:

- Автоматически с помощью DI контейнера через внедрение зависимосетей(конструктор, свойства(не рекомендуется), аргументы методов(new!!!!))
- Внедрить DI контейнер напрямую и разрешать самому

```cs
var service = _container.GetRequiredService<ISomeService>();
```

### Middleware

Middleware - ПО промежуточного слоя. Выстраивается в виде обработчика на конвеере запроса. Алгоритм такой:

1. Получаю запрос
2. Что-то с ним делаю
3. Решаю пускать ли его дальше или нет
4. Пускаю или возвращаю
5. Если пускаю, то могу обработать его еще раз на обратном пути

Настраивается после метода Build()/в методе Configure класса StartUp.
Для настройки используются методы Map, Use, Run

[Docs](https://docs.microsoft.com/ru-ru/aspnet/core/fundamentals/middleware/?view=aspnetcore-6.0)

### Методы Use и Run

Use:

- Метод расширения
- Создание цепочки обработки
- Принимает Func\<HttpContext, RequestDelegate, Task\>: (context, next) -> Task

Run:

- Конечная точка обработки
- Принимает RequestDelegate: (context) -> Task
- Если ничего не передавать - запускает приложение

### Методы Map и MapWhen

[Даже название не изменил](https://metanit.com/sharp/aspnet5/2.22.php)

Map:

- Сопоставляет путь с текущим и если совпал то переходит по требуемому пути исполнения
- Получает строку для сопоставления и builder (т.е. для каждого совпадения отдельный конвеер обработки)

MapWhen:

- Как Map, но с условием

### Создание компонент middleware

Создание:

- Middleware - класс с методом InvokeAsync(HttpContext context, RequestDelegate next)
- Есть интерфейс IMiddleware (не обязательно)
- Добавление в пайплайн - UseMiddleware\<TMiddleware\>()
- Можно создать свои кастомные UseXXX

### Статические файлы

Для обработки статических файлов есть middleware UseStaticFiles. Файлы ищутся по пути WebRootPath из объекта WebHostEnvironment.

### Конвейер обработки запроса

Последовательно добавляем свои Middleware в конвеер. При старте конвеер собирается, а при получении запроса передается в конвеер. Каждый middleware при получении решает что с ним делать: добавляет в ответ какие-то данные, проверяет заголовки, логирует и т.д. Дальше запрос может не передать (UseAuthentication, UseStaticFiles). Последний в конвеере из Use - Run. Он дальше не передает - конечная точка. 
Также для MVC есть свой отдельный пайплайн из фильтров: ResourceFilter, ExceptionFilter, AuthrizationFilter и другие.

### Время жизни middleware

Middleware живет все время существования приложения - singleton.
Поэтому, для внедрения зависимостей transient, scoped лучше использовать внедрение через метод.

### Ведение журнала

Поддержка логирования - встроенная. Для этого есть даже отдельное свойство - Logging.
Логирование может осуществляться во множество путей: файл, консоль, даже сеть.
Есть поддержка уровней логирования:

- None - не логировать
- Debug - для дебага (например, занчения переменных)
- Trace - для трассировки выполнения (например, отслеживать какой метод вызвался)
- Information - главная логика приложения (например, что заказ выполнен, пользователь зарегистрировался)
- Warning - ошибки, не влияющие на выполнение приложения (например, отправка email не работает)
- Error - ошибки, которые влияют на корректное исполнение приложения и должны быть обработаны (например, бд недоступна)
- Critical - пиздец (например, переполнение бд, недостаток памяти)

Для логирования есть метод Log() и его расширения LogInformation и т.д.

Интерполяцию лучше не делать, а передавать аргументы позже (т.к. интерполяция стоит время, а если просто передавать аргументы, то она отложенная)

### Обработка ошибок

Ошибки есть 2 типов - сервера и логики (Exceptions и те, что должны вернуть HTTP 4xx статус).
Если это 2 - то, все ок возвращаем статус (+ страница если нужно).

Если это 1 - то, все плохо. Разработчик, должен понять, что произошло (UseDeveloperExceptionPage), а пользователь не должен такое увидеть (UseExceptionHandler)

В обоих случаях нужно логировать.

### Публикация в Azure

На Azure публикация проста - в Visual Studio кликаем на Publish, выбираем Azure, вводим свои данные, план, место и т.д. и публикуем. (Он вроде сам там скомпилирует(проверить!!))

## ASP.NET Core. Publish & Deploy

### Модель хостинга ASP.NET Core

ASP.NET Core - консольное приложение.

Всего есть 3 встроенных веб-сервера:
1. IIS - Windows only
2. HttpSys - Windows only
3. Kestrel - Cross-platform

По умолчанию используется кросс-платформенный веб-сервер Kestrel, построенный на libuv -
кросс-платформенной библиотеке асинихронного ввода/вывода (аналогия с async/await методов)

Модель хостинга такая:
1. Запрос приходит на веб-сервер (Nginx)
2. Он определяет, что запрос на наш процесс
3. Запрос проксируется на наш сервер (Kestrel)
4. Kestrel отдает запрос нашей логике
5. Kestrel получает результат и возвращает обработанный результат nginx

Причем логика и Kestrel - в одном процессе (большая производительность).
Самого Kestrel недостаточно и ему нужен главный веб-сервер (SSL termination, load balancing...)

На Windows доступен отдельный веб-сервер HttpSys

### Reverse proxy

Proxy открыт в интернет. Его работа - перенаправлять запросы в нужные точки.
Он может поддерживать несколько приложений одновременно.
Например, когда запрос идет на "http://server.com" отдавать запрос внутреннему процессу на порте 5500, 
а когда на "http://another.com/file" отдавать файл index.html.

Также у него могут быть другие рутинные задачи:
- Файрвол
- SSL termination
- Load balancing
- Кэширование

### Run ASP.NET Core app

1. Скомпилировать исходники
```shell
dotnet publish -c Release -o out
```
3. Запустить из папки

### Публикация

1. Установить .NET на сервере
2. Скопировать полученные файлы на сервер

### Запуск опубликованного приложения
```shell
dotnet Assembly.dll
```

### dotnet command

- Для запуска  (.NET Runtime required)
```shell
dotnet run 
```
- Для компиляции
```shell
dotnet build
```

### Независимый деплой

Выходная программа может быть:
- Self-Contained: 
  - есть варианты для всех систем (Windows, Linux, MacOS)
  - \+ сам Runtime
- Framework-Dependent: 
  - компилируем сразу под определенную систему (Windows, Linux, MacOS)
  - Runtime уже должен быть предустановлен

### Как деплоить
- Скопировать файлы на сервер вручную (ssh, ftp, ftps)
- CI/CD
  
### CI/CD

Устанавливаем конфигурацию: на какие действия триггерить систему (например, пуш в main)
При выполнении этого действия запускается система:
1. Собрать исходники вместе
2. Скомпилировать
3. Запустить тесты
4. Выпустить на прод.

Если где-то ошибка - узнаем сразу.

### Развёртывание в IIS

1. Установить .NET Core Windows Server Hosting Bundle
2. Настроить пул приложений для IIS
   1. No Managed Code
   2. Внутри - ASP.NET Core Module
3. Сами приложения - в отдельных процессах (Core module шлет им запросы)
4. Настроить IIS и пула
5. Открыть доступ к пулу

### Пул приложений

IIS работает как Reverse Proxy - перебрасывает запросы на сервер.
В отличие от Kestrel, на каждый запрос не отдельный поток, а целый процесс.
Большая изоляция и безопасность, но скорость меньше.

### Поддержка в коде. Middleware

При конфигурации указать, что используем IIS
```csharp
builder.WebHost.UseIIS();
builder.WebHost.UseIISIntegration();
```

- URL для переброса запросов
- Конфигурация переброса заголовков
- Включение Windows аутентификации (если нужно)

### web.config

Web.config - файл конфигурации, необходимый для запуска IIS (при каждом запуске он должен присутствовать).
Лежит где и само приложение.

### Хостинг приложений под Linux

Linux - top:
- Удобная настройка
- Меньше требований к железу
- Дешевле стоимость сервера

### Run ASP.NET Core app on Linux

1. Скомпилировать приложение
2. Установить .NET Runtime на сервер
3. Отправить приложение на сервер
4. Настроить reverse proxy (nginx)
5. Настроить process management (systemd)

### ASP.NET Core in Docker

Сейчас все в основном запускают в контейнерах. 
Обычно это Docker.
Для .NET есть уже готовые образы для разных типов Runtime.

### Docker

Docker - движок ОС виртуализации.
Ты запускаешь на Windows контейнер с образом Linux и твое приложение думает, что он работает в Linux.
(Вообще идея построена на cgroups - фича Linux, в Windows через жопу).

Концепции:
- Образ - единица развертывания, шаблон
- Контейнер - запущенный образ
- Dockerfile - файл конфигурации для создания образа
- Docker compose - утилита для создания группы взаимосвязных контейнеров
с легкой конфигурацией прочих вещей (сеть, аргументы ...)

### Потенциальные проблемы при деплое

- Изменения IP при пробрасывании запроса
- Пришедший запрос по http, не https


### Разница между Linux и Windows

- LF vs CRLF:
в Linux конец строки = '\n', в Windows = '\r\n'
- '\' vs '/':
в Linux разделитель - '/', в Windows = '\'
- Запрещенные символы в переменных окружения:
Regex для Linux ~ [a-zA-Z_]{1,}[a-zA-Z0-9_]{0,}

### Конфигурирование

Лучше иметь возможность выставлять конфигурацию приложения не в compiletime, а в runtime.
Для этого нужна конфигурация. 
В ASP.NET Core есть интерфейс IConfiguration откуда можно получить конифгурацию.
Источники: переменные окружения, аргументы командной строки, файлы, внешние конфигурации (запросы).
Например, строки подключения получать из переменных окружения, а кол-во попыток переподключения - из файла.

### Бандлинг/минификация

Цели:
1. Уменьшить трафик между клиентом и сервером
2. Уменьшить время рендеринга/отклика приложения

Для этого:
1. Посылаемые файлы нужно упаковать как можно плотнее - минификация.
Пример, `script.min.js` или `style.min.css` из React
2. Отправить все необходимое одним файлом, объединить все вместе - бандлинг
Пример, после сборки файлов в React, у нас есть только 1 файл со стилем, хотя в процессе было несколько `App.css`, `Header.css`...

## ASP.NET Core. Middleware

### Обработка запроса

1. Запрос принимается
2. Выстраивается конвеер обработки запроса
3. Запрос последовательно проходит по Middleware
   1. Каждый из них обрабатывает запрос
   2. Решает передавать ли дальше
4. По достижении конца, проходит обратный путь

### HttpContext

HttpContext - абстрактный класс, представляющий контекст запроса:
- Request - запрос
- Response - ответ
- User - информация о пользователе
- Connection - соединение (порт, адрес...)
- RequestServices - контейнер сервисов
- Items - дополнительные объекты

### HttpRequest

Представляет собой контекст запроса:
- Метод
- Схема
- Путь
- Хост
- Запрос
- Протокол

### HttpResponse

Контекст ответа:
- Статус код
- Заголовки
- Тело ответа
- Writer - для записи ответа
- Длина ответа
- Тип ответа

### Middleware

Промежуточный слой обработки запроса.
1. Обрабатывает запрос до и после передачи дальше
2. Решает передавать ли дальше

### Примеры

```csharp
app.Use(async (context, next) =>
{
    if (context.User.HasClaim(c => c.Type == "SlavesCount" && int.TryParse(c.Value, out var count) && count > 0))
    {
        await next();
    }
    else
    {
        await context.Response.WriteAsync("Not enough slaves count to perform action");
    }
});
```

### Middleware Pipeline

- Двусвязный список middleware
- Либо терминальный, либо содержит ссылку на следующий

### Выстраивание конвейера

С .NET 6:
- Добавление в WebApplication перед `app.Run();`
До:
- В методе `Configure()`;

### Методы Use, Map, Run, MapWhen

Run:
- Конечная точка обработки запроса (дальше не передает)

Use:
- Добавляет middleware в пайплайн

Map:
- Сопоставляет Path с требуемым, и если совпадает, то передает запрос
на выполнение уже другому пути выполнения

MapWhen:
- Как `When`, но есть условие для выполнения

### Проблема с формированием ответа

После записи ответа в Response его менять нельзя:
изменится Content-Length, Content-Type и т.д.

### Кастомные компоненты Middleware

Есть метод расширения `UseMiddleware<TMiddleware>();`. 
Принимает класс, в котором:
- Есть публичный метод `void Invoke(HttpContext context)` + Конструктор принимает `RequestDelegate`
- Если публичный метод `Task InvokeAsync(RequestDelegate next, HttpContext context);`
  
Хорошая практика - для своих типов Middleware отдельные методы расширения 

### Дополнительные параметры

В конструтор класса Middleware можно делать инъекции зависимостей.

### Порядок вызова

Порядок вызовов такой же как и на этапе построения WepApplication.

### Middleware обработки ошибок

Перадает запрос дальше. На обратном пути проверяет на ошибки Response.

### Middleware vs Services

Middleware - ответственен за логику обработки запроса

Services - ответственны за бизнес логику приложения

### Маршрутизация в ASP.NET Core

Включается с помощью `app.UseRouting()`;

Для навигации используется концепция конечных точек.

### Конечные точки

Конечная точка, Endpoint - логическая конечная точка обработки запроса.
Определяет делегат для обработки + метаданные (информацию из строки запроса...)

### Шаблоны маршрутов

Шаблоны представленны как Regex (не Regex). Общий вид такой
`must-be-here/{lanuguage:regex(^\w\w-\w\w$)}/{parameter=default-value}/{date:date}/{**other}`
- {...} - параметр для сопоставления
- :regex(), :date - сопоставление со значением и его типом в адресе
- =default-value - значение по умолчанию (если нет)
- **other - все остальное

### Маршрутизация - Концепции

Запуск middleware:
- До UseRouting:
  - Изменение данных для работы с маршрутизацией: переписывание пути, изменение метода, изменение базового пути
- После UseRouting:
  - Добавление метаданных
  - Проверка безопасности

### Совпадение маршрутов

Из всех путей выбирается наиболее конкретный.

Более конктретные:
1. Большее число сегментов (api/images - api/images/total)
2. Сегмент с литеральным (вшитым) текстом (api/{version} - {method}/{version}) 
3. Сегмент с ограничением ({date:date})
   
Менее конкретные:
1. Всеобъемлющие параметры ({**args})

### Генерация URL-адресов

LinkGenerator - синглтон объект, для генерации ссылок.
Используется в HTML helper, URL helper, Tag helper, ActionResult.
Устанавливает связь между различными действиями/точками в MVC.

### Обработка ошибок

Можно создать специальную страницу, которая будет выдаваться при ошибке.
`app.UseExceptionHandler('/Error')`

В шаблонах MVC, RazorPages - уже встроена.

### Обработка ошибок HTTP: UseStatusCodePagesWithRedirects vs UseStatusCodePagesWithReExecute

Для статус кодов 400-599 есть специальные обработчики для каждого случая.

Каждый из них может принимать строку, в которой можно указать параметр '{0}'. В него будет всталяться статус код.

```csharp
app.UseStatusCodePages();
app.UseStatusCodePagesWithRedirect();
app.UseStatusCodePagesWithReExecute();
```

### Использование Cookie

Для кук есть свои свойства в Request и Response:

```csharp
context.Response.Cookies
context.Request.Cookies
```

Причем в Response - только модифицировать, а в Request - только читать.

### Сессии

1. Добавляем сессии в Services
```csharp
builder.Services.AddSession();
```
2. Добавляем сессию в пайплайн
```csharp
app.UseSession();
```
3. Получаем доступ к сессии из объекта Session
```csharp
app.Run(async (context) => 
    await context.Response.WriteAsync(context.Session.GetString("UserName")));
```

## ASP.NET Core. Services & DI

### Сервисы - зависимости

Сервис - объект, занимающийся какой-то логикой
- Middleware зависит от сервисов
- Сервис зависит от другого сервиса

### Пример зависимости

```csharp
public class AzureTimeService: ITimeService
{
    private readonly IAzureRequester _requester;
    public AzureTimeService(IAzureRequester requester)
    {
        _requester = requester;
    }
    
    public DateTime GetCurrentTime()
    {
        return _requester.GetTime();
    }
}
```

### Проблемы прямых зависимостей

- При изменении 
  - Заменить класс во многих местах
  - Зависимые классы тоже изменятся
- Как тестировать?

### S.O.L.I.D

*S* - Single Responsibility, делать что-то одно, но хорошо
*O* - Open/Closed, закрыт для модификаций, но открыт для расширений
*L* - Liskov Substitution, использование отнаследованных классов в качестве базовых, даже не зная об этом
*I* - Interface Segregation, много маленьких интерфейсов для специальной задачи
*D* - Dependency Inversioin, используем интерфейсы и нигде конкретные классы

### ServiceLocator

Анти-паттерн: 
- Все зависят от него
- Должен знать обо всех

### DI анти-паттерны

1. Control Freak - не использование интерфейсов, везде создаешь все сам с помощью new()
2. Bastard Injection - несколько конструкторов, с дефолтными значениями -> увеличение зависимостей
3. Constrained Construction - требование иметь специализированный конструктор
4. Service Locator - гранулированное получение зависимостей в отдельных частях кода, зависим от этого Service Locator

### IoC (Inversion of Control)

Если есть контейнер, который просто регистрирует у себя типы, а затем строит граф зависимостей, 
и при требовании создать объект использует этот граф для построения - то получаем IoC контейнер.

Динамически регистрируем необходимые типы, а контейнер сам разберется как создавать.

- Autofac
- Ninject
- Unity
- Castle Windsor
- StructureMap
- Встроенный
- Кастомный

### Свой тривиальный контейнер

Есть класс Activator с методом CreateInstance. 
Вызываем его, передавая тип, который нужно создать.
Пусть он сам разберется, что туда класть.
Главное - реализовать интерфейс `IServiceProvider`

### IServiceProvider

`IServiceProvider` - интерфейс IoC контейнера для использования в ASP.NET Core.
Есть встроенный, но можно переопределить (так же как и обычные сервисы).
За временем жизни следит ASP.NET Core.

### Регистрация сервисов

Регистрация сервисов в WebHostBuilder через метод свойства Services

```csharp
builder.Services.Add(SerivceDescriptor descriptor); // Общий вид
```

### IServiceCollection Extension methods

Для удобства есть предопределенные методы

```csharp
builder.Services.AddTransient(); // Каждый раз новый
builder.Services.AddScoped(); // Один на запрос
builder.Services.AddSingleton(); // Один на всю работу
```

### Время жизни

ASP.NET Core определяет 3 типа времени жизни:
- Transient - на каждое требование создается новый экземпляр
- Scoped - на каждый HTTP запрос будет создаваться ровно один экзепляр 
(в более общем смысле - создается область видимости Scope, в которой живут объекты)
- Singleton - создается один раз, на все время жизни приложения

### Варианты регистрации

- `Add{Transient|Scoped|Singleton}<TService, TImplementation>()`
- `Add{Transient|Scoped|Singleton}\<TImplementation\>()`
- `Add{Transient|Scoped|Singleton}\<TService\>(Func<ServiceProvider, TImplementation> creator);`
- `AddSingleton\<TImplementation\>();`
- `AddSingleton(TImplementation implementation);`

`TryAdd{Transient|Scoped|Singleton}` - регистрация, если другие реализации не зарегистрированы

### Общая схема работы

1. Запрос приходит
2. Создается ServiceProvider
3. Создается Scope
4. Создаются зависимости

### Типичные ошибки с Lifetime

Главная ошибка - Инъекция в конструктор сервисов с меньшим временем жизни:
- Scoped в Singleton
- Transient в Singleton

### Резолв из transient сервиса scoped или singleton зависимостей

- Инъекция в конструктор
- Инъекция самого IServiceProvider - каждый раз самим создавать scope и резолвить

### GetService\<TService\>()

Во 2 случае мы инъектим IServiceProvider - получается ServiceLocator (нужно избегать).
Само получение зависимостей - через метод расширения `GetService\<TService\>()`;

### Несколько сервисов или интерфейсов

Если на сервис зарегистрировано несколько реализаций, то:
- Нельзя получить только 1
- Получение через коллекции - `IEnumerable\<TService\>`, ` ICollection\<TService\>`

### Рекомендации по созданию сервисов

- Single Responsibility Principle - маленькие интерфейсы ответственные за небольшой функционал
- Избегать состояния/статики (лучше уж синглтон)
- Убрать прямые зависимости
- Использовать Dependency Inversion (инъекция зависимостей через интерфейсы)

### Disposal of services

За очистку ответственнен IServiceProvider (не нужно самим вызывать Dispose()).
Но если сервис создается вами, то нужно. 
Например, если резолвишь фабрику, а эта фабрика уже сама создает объект IDisposable (здесь не контейнер создает!!)

### Рекомендации по использованию сервисов

1. Конструктор - синхронный, асинхронного резолва быть не может!
2. В контейнере хранить только сервисы. Если нужна конфигурация - паттерн Options:
резолвить специальный тип `IOptions\<TOptions\>`.
3. Не использовать статический доступ
4. Предпочитать DI ServiceLocator`у
5. Если сервис Transient и реализует IDisposable - то, может получиться, что метод Dispose не вызовется,
т.к. Dispose() будет вызван либо когда Scope выключится, либо когда приложение выключится
6. Проверять, что время жизни в графе зависимостей - правильное (проверяется автоматически в Development режиме)

## Архитектура приложений ASP.NET Core MVC

### Монолитное приложение

Все сервисы/логика в одном процессе: представление, логика, обращение к бд... 

### All-in-one приложения

Грубо говоря, в одном *.csproj - все необходимые файлы:
- интерфейсы
- миграции
- реализации
- представление

Нет разделения даже на отдельные сборки.

### Слои приложения

Лучше разделять приложения на множество отдельных слоев. 
Основые виды разделения:
- By feature: сборка - отдельная готовая фича
- By layer: сборка - отдельный слой обязанностей (доступ к данным, бизнес-логика, консоль...)

Предпочтительнее By layer:
- Облегачается тестирование
- Многократное использование
- Упрощение замены
- Ограничение взаимодействия

### Правильные зависимости

Зависимости должны быть минимальными и необходимыми. 
Традиционное разбиение на слои:
- Инфрастурктура (DAL, Data Access Layer)
- Бизнес-логика (BL, Business Logic)
- Само приложение (UI, Web, Console, Windows)
- Тесты (Tests)

При возникновении зависимостей - Dependency Inversion

### Чистая архитектура

> БАТЯ!! Все должны ему поклоняться!!!

Идея следующая:
1. Разбиваем приложение на слои
2. Верхние слои знают о низлежащих, но низлежащие не знают о вышележащих:
Бизнес-логика не знает о том, какая БД используется (и используется ли вообще),
но UI должен знать о бизнес-логике (а как иначе?)

UI -> Infrastructure -> BL (Зависимости)

### Распределение по слоям
1. Ядро приложения - Бизнес-логика:
   - В ней содержится логика приложения.
   - Все зависят от нее
   - Если нужны сервисы (например, получения из-вне чего-то), то определяем для этого интерфейсы
   - Типы данных ядра приложения:
     - Сущности
     - Типы-значения
     - Агрегаты
     - Сервисы/Интерфейсы
     - Доменные исключения
     - Доменные события/обработчики
2. Инфраструктура - Доступ к данным
   - Доступ к данным (например, реализация сервиса получения чего-то)
   - Реализация сервисов, описанных в BL
   - Типы данных слоя инфраструктуры:
     - Репозитории
     - DbContext (EF Core)
       - Специфичные сервисы (отправка сообщений, событий)
   - Для доступа к данным есть 2 паттерна:
     1. Репозиторий:
        - Методы: Get, Delete, Add
        - Нет метода Update, отслеживание изменений - неявное
        - Позволяет легко мокать при тестировании  
     2. Unit of Work
        - Объединяет несколько репозиториев
        - Транзакционно обновляет данные
        - Есть метод Update (~ Commit в SQL)
     3. Repository и UoW в .NET:
        - UnitOfWork - это DbSet
        - Есть поддержка обоих
        - Оборачивать в свои? - Если очень хочешь
3. Уровень пользовательского интерфейса (ASP.NET Core):
    - Объединяет все воедино
    - Точка входа в приложение
    - Типы данных UI:
      - Filter
      - Middleware
      - Controllers
      - Views
      - ViewModels
### UI ASP.NET Core

Для отображения UI в ASP.NET Core есть встроенный фреймворк MVC с движком представлений Razor.
UI можно рендерить:
- Client Side:
  - Blazor
  - JS
- Server Side:
  - Razor Pages
  - MVC
- Hybrid
  - Blazor + MVC


### ASP.NET Core MVC / Razor Pages

MVC - общий паттерн создания приложений.
В ASP.NET Core - это middleware + services (контроллеры).

Razor Pages - облегченный вариант MVC, когда у нас только 1 страница.

### Model / ViewModel

Model:
- Состояние приложения
- Не модель предметной области, но бизнес-логику имеет
- Описывает классы для передачи и отображения данных
  
ViewModel:
- Используется для отображения 
- Аггрегирует и фильтрует несколько моделей, 
так чтобы передавать только то, что нужно показать

### Контроллеры

- Реагирует на ввод и действия
- Контроллер = наследуется от ControllerBase | имеет атрибут Controller | имеет суффикс Controller
- Методы этого класса - конечные точки обработки

### Действия (action)

Действие - это метод контроллера (публичные и непомеченные атрибутом `[NonAction]`).
Могут иметь различные возвращаемые значения: void, string, int, IActionResult.

### IActionResult

Основной результат действия. Есть стандартные реализации:
- ContentResult - строка в ответе
- EmptyResult - 200 OK
- FileResult (VirtualFileResult, PhysicalFileResult, FileStreamResult, FileContentResult - потомки) - файл
- ObjectResult - произвольный объект
- JsonResult - объект в виде JSON
- ViewComponentResult - рендеринг ViewCompoment
- ViewResult - рендеринг представления
- StatusCodeResult - просто статус код
- ChallengeResult - проверка аутенитфикации

### IActionResult: redirect

Если в результате действия нам нужно перенаправить пользователя (3xx StatusCode):
- RedirectResult - 302 или 301
- RedirectToRouteResult - по указанному маршруту
- RedirectToActionResult - на действие контроллера 
- RedirectToPageResult - на страницу Razor
- LocalRedirectResult - в рамках этого приложения ("~/Controller/Action")

### Валидация модели

Для валидации используются атрибуты унаследованные от ValidationAttribute:
- `[Required]`
- `[MinLength(6)]`

Можно определить свои.
При запросе модель автоматически валидируется и результат валидации доступен в ModelState.
IsValid - свойство сигнализирующее о валидности принятой модели.
Если для класса установлен атрибут [ApiController], то при неправильной модели, автоматически будет возвращаться 404 с описанием ошибок.

### Представления

Формируются на сервере с помощью движка представлений. 
По умолчанию используется Razor, но его можно заменить на другие.

Для генерации используются шаблоны (cshtml).

### Razor

Движок представлений. 
Синтакис:
- Код C# - префикс '@'
- Допускаются однострочный (@(...)) и многострочный код (@{...})
- Допускаются локальные переменные, условия, циклы, функции
- Поддержка внедрения зависимостей

### Передача данных в представления

Передача данных в модель может быть несколькими способами:
- ViewData, ViewBag, TempData - объекты MVC с доступом по ключу/свойству
- Model/ViewModel - напрямую передаваемые объекты

### Вспомогательные функции тегов

Для html тегов можно определить свои собственные теги.
Они обрабатываются на сервере и не пересылаются клиенту.
Пример:

```html
<label asp-for="UserName">Enter username:</label>
<input asp-for="UserName"/>
```

### Скаффолдинг

Технология, позволяющая генерировать типовые элементы для проекта.
Например, обычно контроллер должен уметь читать, писать и обновлять, поэтому
можно сгенирировать контроллер по этому шаблону, а затем немного его изменить.

Скаффолдить можно:
- Контроллеры
- View
- Area
- Identity

### Маршрутизация

Маршрутизация - часть MVC. 
В настройке конвеера можно задавать стандартные маршруты:
- Название
- Путь
- Параметры пути
- Аргументы пути

После настройки, с помощью Url.RouteUrl можно генерировать пути на основании его названия и аргументов.

### Атрибуты маршрутизации

Маршрутизацию можно настроить с помощью атрибутов:
- [Route(template)]
- [Http{Get|Post|Delete|Patch}(template)]

Route - для всех методов. Http*() - для контретных методов. 
template - тот же самый шаблон, что и в конвеере (поддерживает типы, параметризацию, аргументы и т.д.).

### ControllerContext

При наследовании от Controller, нам становятся доступны его свойства:
- RouteData - параметры маршрута с вычлененными оттуда значениями из шаблона
- ModelState - состояние валидности модели
- HttpContext - контекст запроса

### Передача параметров в запросе

В запросе можно передавать значения из различных источников:
- Строка запроса
- Тело
- Форма
- Путь


### model binding, массивы/объекты

Model Binding - привязка данных.

В аргументы метода контроллера можно передавать значения. 
Они будут браться из значений запроса.
Можно указать из какого конкретно источника нужно забирать значения ([FromBody], [FromForm]...)
Можно передавать как простые, так и сложные объекты.
Для массивов - передача либо все с 1 именем (`?items=1&items=2&items=3`), 
либо указывать их индекс в массиве (`?items[2]=1&items[0]=2&items[3]=3`).


### Загрузка файлов

Для работы с передаваемыми файлами есть специальный интерфейс `IFormFile`

### Работа с файлами - Безопасность

Аспекты:
- Для отправки файлов - выделенная защищенная область
- Сохранять в полученные файлы в отдельной от программы директории
- Имя файла определять самим
- Использовать только разрешенные разрешения файлов
- Установить максимальный размер файла
- Проверять контент файла перед сохранением, на содержание вредоносного ПО

### Инъекции зависимостей

В MVC инъекция зависимостей можно совершать через:
- Конструктор
- Свойства
- Аргументы методов
- Представления (`@inject TService ServiceName`)

## ASP.NET Core Auth*

### Фильтры MVC

Фильтр - объект, позволяющий выполнять определенный код до и/или после выполнения основного метода.

### Виды фильтров

1. Авторизации
2. Ресурсов
3. Действий
4. Исключений
5. Результатов действий

Образуют свой конвеер фильтров. На обратном пути работают только фильтр ресурсов и результатов.

Также есть отдельный фильтр RazorPages

### Создание фильтров

Фильтр должен реализовать свой интерфейс:
- Авторизации - IAuthorizationFilter
- Ресурсов - IResourceFilter
- Действий - IActionFilter
- RazorPages - IPageFilter
- Исключений - IExceptionFilter
- Результатов - IResultFilter

Это синхронные фильтры. Асинхронные имеют префикс Async после I (IAsyncActionFilter).

### Добавление фильтров

Фильтры могут быть добавлены:
- Глобально, в опциях MVC
```cs
builder.Services.AddMvc(options =>
        {
            options.Filters.Add(new SomeFiler());
        });
```
- Через атрибуты. Для этого нужно не только реализовать интерфейс, но и наследоваться от Attribute.
Добавлять - как атрибуты методов

### Identification / Authentication / Authorization

Identification - кто ты: назвать имя, username (PK - в общем случае)

Authentication - подтвердить что это ты: назвать пароль, passphrase, секретное слово

Authorization - есть ли у тебя права для этого: в какой ты роли, сколько тебе лет, из какой страны

Без вышележащего не может быть выполнено нижележащее: без аутентификации нельзя авторизовать (логично)

### Способы аутентификации
- По сертификатам: подписанный каким-нибудь авторитетом сертификат. 
Применяется в сертификатах SSL.
- По одноразовым паролям: SMS/EMAIL verification code (2FA)
- По ключам доступа: API key, Access token
- Аутентификации по паролю: username/password
  - HTTP authentication: 
Заголовок `Authorization: <type> <data>` 

type: Basic, Bearer, HOBA, Mutual, OAuth, Digest
data: данные закодированные base64.
Например, Basic = base64encode({username}:{password})
  - Forms authentication: в HTML форме логин, пароль.
Они с запросом передаются на сервер.
  - URL query: логин/пароль передаются в параметрах URL - небезопасно
  - Request body (POST, PUT, PATCH) - передача данных в теле запроса, в специальном виде, например, json или xml. 

### Аутентификация по паролю - Уязвимости

1. Простые пароли
2. Брут-форс атаки
3. Передача в незашифрованном виде
4. Нет возможности смены пароля
5. Уязвимость восстановления/смены пароля
6. При смене нет требований повторного ввода пароля
7. Эксплуатация сохраненной сессии

### Аутентификация по токенам

Есть Identity Provider - владеет аккаунтами. 
Другие - клиенты, ими пользуются, путем создания для себя токенов доступа описывающих пользователей (действующих от имени пользователя).
SSO - один раз зарегистрировался, в остальных местах используешь аккаунт.

Стандартов несколько:
- OAuth
- OpenID Connect
- SAML
- WS-Federation

### Форматы токенов

- SWT (Simple Web Token) - ключ-значение в формате HTTP формы
- JWT (JavaScript Web Token) - 3 поля:
  - header: метаданные
  - payload: информация о токене (время действия, кому, от кого)
  - sign: подпись
- SAML (Security Assertion Markup Language) - токены в XML формате

### Аутентификация в ASP.NET Core

Встроена из коробки

### HttpContext.User

Свойство, представляющее данные о пользователе в формате ключ-значение (Claims).

### ClaimsPrincipal

Набор утверждений (claims) о пользователе: username, email, date... 
в формате ключ-значение. 

### Claims vs Roles approach

Roles - устаревший, в HttpContext.User есть метод IsInRole только для совместимости.
Claims дает больше информации о пользователе.

### Процесс аутентификации

1. Клиент вводит логин/пароль и отправляет запрос на сервер
2. HttpContext.User выставляется в Anonymous
3. При успешной аутентификации - пользователь аутентифицируется (HttpContext.SignInAsync, SignInManager.SignIn)
4. Выставляются специальные зашифрованные куки представляющие пользователя
5. При дальнейших входах, куки парсятся и выставляется HttpContext.User

### Middleware. Добавление в обработку

Для рутинной проверки авторизованности - UseAuthentication/UseAuthorization - из коробки.
Поддержка нескольких источников: куки, Authorization header и другие.

### Задачи аутентификации

1. Определить, что пользователь не подделка
2. Проверка уровня доступа к ресурсам.

### Схема аутентификации

Схема аутентификации - название обработчика + его настройки (Cookies, Google, OAuth, Bearer...).
Следует указывать схему по умолчанию.

### Создание аутентификационной куки

```csharp
var claims = newList<Claim> {     
        newClaim(ClaimTypes.Name, user.Email),     
        newClaim("FullName", user.FullName),     
        newClaim(ClaimTypes.Role, "Administrator"), 
        }; 
var claimsIdentity = newClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme); // Здесь можно задать доп.параметры, например, RedirectUri, ExpiresUtcи т.д.
var authProperties= newAuthenticationProperties();  
await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme,      
                              newClaimsPrincipal(claimsIdentity),      
                              authProperties);
```

### Удадение и обновление куки

```csharp
await HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme); // обновление
var claims = newList<Claim> {     
         newClaim(ClaimTypes.Name, user.Email),     
         newClaim("LastChanged", {Database Value}) 
         };  
var claimsIdentity= new ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme);  
await HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, new ClaimsPrincipal(claimsIdentity));
```

### ASP.Net Core Identity

Фреймворк для работы с пользователями. 
Имеет поддержку многих стандартных случаев:

- Смена пароля
- Обновление почты
- Подтверждение почты

Нужно устанавливать отдельно, как NuGet пакет.


### Возможности Identity

- Готовая схема БД
- Валидация пароля
- Блокировка пользователей
- 2FA
- Токены для смены почты/пароля/username
- Отслеживание изменений свойств пользователя
- Возможность интеграции со сторонними провайдерами

### Кастомизация Identity

- Почти всё - шаблоны (нужно наследоваться от них и делать свое)
- Свои сервисы хеширования/генерации токенов
- Внешние провайдеры
- Свои Claims

### Сервисы Identity

```csharp
builder.Services.AddDefaultIdentity<DefaultUser>(options => 
                options.SignIn.RequireConfirmedAccount = true)
                .AddEntityFrameworkStores<DefaultDbContext>();
```

### Настройка Cookie для Identity

Куки настраиваются так же - через 

```csharp
builder.Services.ConfigureApplicationCookie(options => {
    options.Cookie.Name = "SomeName";
    options.LoginPath = "/Identiy/Account/Login"; // Можно поменять на свои
    options.AccessDeniedPath = "/Identity/Account/AccessDenied";
});
```

### Identity’s database schema

Есть шаблон для баз данных. В ней определены таблицы (для SQL):
- AspNetUsers
- AspNetUserRoles
- AspNetRoles
- AspNetRoleClaims
- AspNetUserTokens
- AspNetUserLogins
- AspNetUserClaims


### Сервисы

Из коробки доступны 2 основных необходимых объектов:
 
- SignInManager
- UserManager

### Кастомизация пользователей

Переопределяем базовый DbContext - IdentityDbContext (можно использовать IdentityUserContext - без ролей).
Наследуемся от IdentityUser и добавляем/переопределяем что нужно. 
Везде где нужен тип пользователя - даем наш тип.

### Кастомные claims

Можно хранить не только предопределенные типы Claims (Email, UserName...),
но и свои - `new Claim("CustomClaimName", claimValue);`

### Simple Authorization

`[Authorize]`

### Авторизация по ролям

`[Authorize(Roles = "Admin, Manager")]`

### Authorization Policy

Политика авторизации - правило для доступа к ресурсу.
Проверка не только того, что пользователь вошел в аккаунт,
но и того, что соответствует какому-то правилу.

### Добавление политики авторизации

1. Добавляем политики авторизации в builder
```csharp
builder.Services.AddAuthorization(options => {
    options.AddPolicy("OnlyInRussia", p => p.RequireClaim(ClaimTypes.Locality, "Russia"));
});
```
2. Указываем политику в атрибуте `[Authorization("OnlyInRussia")]`

### Ограничения политик (методы)

- RequireAuthenticatedUser() - пользователь аутентифицирован
- RequireClaim(claim) - есть claim с таким названием
- RequireClaim(claim, value) - есть claim с таким названием и значением
- RequireRole(role) - в одной из роли
- RequireUserName(name) - UserName равен этому
- RequireAssertion(handler) - свой тип проверки
- AddRequirements(requirement) - добавить свои требования

### RequireAssertion(handler)

```csharp
builder.Services.AddAuthorization(options => 
    options.AddPolicy("DungeonMaster", policy => 
        policy.RequireAssertion(context => 
            context.User.HasClaim(c => 
                c.Type == "Role"
                && c.Value == "DungeonMaster"))));
```

### Пример авторизации
```csharp
[Authorize("DungeonMaster")]
public IActionResult SlavesCount()
{
    return Ok(new {_slaves.Count});
}

[Authorize(Roles = "Slave, Timur")]
public IActionResult GoToDungeon()
{
    if (_slaves.Any())
    {
        _slavesManager.AddSlaveToDungeon(_slaves.First());
        return Ok();
    }
    return NotFound();
}
```

### Пример своего ограничения

1. Определяем тип своего ограничения
```csharp
class MinimumAgeRequirement
{
    public int MinimumAge { get; }
    public MinimumAgeRequirement(int age)
    {
        MinimumAge = age;
    }
}
```
2. Определяем свой обработчик
```csharp
class MinimumAgeRequirementHandler: AuthorizationHandler<MinimumAgeRequiremnt>
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, MinimumAgeRequirement requirement)
    {
        var birthDate = DateTime.Parse(context.User.First(c => c.Type == ClaimTypes.DateOfBirth));
        if ((birthDate.Today.Year - birthDate.Year) < requirement.Age) context.Successed(requirement);
        return Task.CompletedTask;
    }
}
```
3. Регистрация своего ограничения
```csharp
builder.Services.AddAuthorization(options => 
    options.AddPolicy("WorldOfTanksEnjoyers", policy =>
        policy.Requirements.Add(new MinimumAgeRequirement(40))));
```

### Использование контекста MVC. 

В объекте `AuthorizationHandlerContext` есть свойство Resource. Его тип - `object?`.
Через него можно передавать различные объекты необходимые для проверки прав.

### Resource-based authorization

Мы можем проверять основываясь не только на AuthorizationContext,
но и на объекте, предоставленном нам.

Например, мы хотим передавать в handler объект документа, для проверки прав редактирования.
Тогда мы можем вызвать метод `AuthorizeAsync` интерфейса `IAuthorizationService` и передать этот документ.
Он будет доступен через свойство `Resource` объекта `AuthorizationHandlerContext`.

В представления можно внедрять зависимости. Поэтому можно внедрить интерфейс IAuthorizationService и 
уже в самом коде представления проверять уровень доступа (*.cshtml)

```csharp
@inject IAuthorizationService Service
@if (await Service.AuthorizeAsync(User, "EditImage").Succeeded)
{
    <button id='enter-edit-mode'>Edit</button>_
}
```

## ASP.NET Core. Security

### SSL

SSL (Secure Socket Layer) - криптографический протокол, для более безопасной связи. 
Шифрование происходит над HTTP трафиком. 

- Ассиметричное шифрование - обмен ключами
- Симметричное шифрование - сохрание конфиденциальности
- Коды аутентификации - целостность сообщений

Принцип работы:
1. Клиент шифрует открытым ключом сообщение
2. Сервер дешифрует принятое сообщение приватным

И наоборот

### Сертификаты

Сертификат - спец. документ, удостоверяющий что у владельца есть опеределенные права. 
В случае с криптографией (TLS, SSL) это файл формата X.509, в котором содержится информация о:

- Имени, адреса держателя, названия организации
- Открытый ключ
- Дата проверки сертификата
- Серийный номер серитфиката

Используется для установления защищенного соединения при подключении. 
Хранится на сервере в определенной директории. 


### Атака Open Redirect. Защита

В URL может быть прописан адрес *redirectUri*, который ведет на совершенно другой сервер.
Например, после авторизации может быть редирект ссылка на вредоносный сайт, тогда при получении такого запроса
хакер знает, что запрос пришел с такого адреса и попытается получить данные аккаунта.

Шаблон параметра: redirectUrl, returnUrl, return-url, redirect-url 

Для защиты необходимо не просто проверять, что параметр returnUrl присутствует, 
но и валидировать его хост (DNS имя сервера), 
чтобы возврат происходил на тот же адрес

### Защита данных

Секреты приложения должны быть доступны только авторизованным пользователям.
Чтобы ограничить доступ к ним можно:

- Шифровать весь проходящий трафик
- Хранить важные данные только в зашифрованном виде
- Не хранить критические данные в общедоступном месте (не в репозитории, например)

### Шифрование данных (CryptoAPI)

Чтобы данные были защищены, их нужно зашифровать. 
Из коробки есть интерфейс IDataProtector у которого есть метод Protect: byte[] -> byte[], string -> string 

### Установка времени жизни

Для некоторых типов данных нужно уметь хранить их определенное время.
У IDataProtector есть метод ToTimeLimitedDataProtector.
Он может установить период валидности зашифрованных данных. 

### Хранение паролей

Пароли хранить только в шифрованном виде!
Использовать криптостойкие алгоритмы и желательно пройти по несколько раз.
Также стоит добавить к ним соль, чтоб уж наверняка.

### Настройка криптографии

Настройка криптографии в ASP.NET Core - также как и остальные сервисы.
Есть встроенная криптография: 
```cs
builder.Services.AddDataProtection()
                .SetDefaultKeyLifetime(TimeSpan.FromMinutes(30));
```

### Клиентские уязвимости

- XSS, Cross Site Scripting
- L/RFI, Remote/Local File Include
- JSON Injection
- XEE, XML extenal entity
- ClickJacking

### Same-origin policy (SOP)

SOP - политика, определяющая как документ или скрипт, 
загруженный из одного источника может взаимодействовать с ресурсом из другого источника.
Изоляция потенциально вредоносных документов.
В кратце, запись - разрешена, чтение - нет (не везде, например, между iframe ничего cross-origin) 

### Что такое Origin

Origin = scheme + host + port.
Поменяешь хоть что-то одно - это другой Origin.

- http != https
- 80 != 443
- app.domain.com != app2.domain.com
- http://vk.com:20 == http://vk.com:20/me
- https://github.com != https://github.com:444

### Суть XSS. Пример

Нельзя с другого Origin просто так получить контент/сделать запрос. 
Для доступа с других Origin нужно выставить CORS заголовок.

Пример:
1. Захожу на рандомный сайт.
2. Оставляю коммент, в котором есть скрипт
3. Этот скрипт отправляет GET запрос на мой сервер, в котором есть все куки
4. Среди кук я нахожу твой Access/Refresh token
5. Через время запускаю DDoS на Яндекс
6. Виноват ты (формально)

### Как предотвратить инъекции

Нужно:
1. Валидировать/фильтровать входные данные
2. Санитизировать (экранизировать, например) выходные данные

### Валидация и фильтрация. Санитизация. Общие правила. Razor

- Фильтрация предпочтительнее по белым спискам ("всем кому можно", а не "всем, кроме")
- Используем специальные политики для каждого запроса (страна, возраст, пасспорт и т.д.)
- Не размещать недоверенные данные во входе
- Профильтровать каждый вход URL/HTML/JS
- Razor автоматически санитизирует HTML

### Content Security Policy (CSP)

Content Secure Policy - политика, определяющая из каких источников можно получать контент (скрипты, css, html ...).
В ответе сервера выставляется заголовок Content-Security-Policy, в котором выставляются специальные директивы использования. 
Обязательно нужно включать default-src (fallback).

Примеры применений (атрибуты для выставления):
- Только с сервера: default-src 'self'
- Только с сервера и доверенного источника: default-src 'self' *.trusted.com
- Только сервера, но если пользователь вставит медиа, то с разрешенных: default-src 'self'; img-src *; media-src trusted-media.com; script-src static.domain.com
- Весь получаемый контент по SSL: default-src https://some-address.com
- Изображения из любых источников, но запретить JS: default-src 'self' site.com; img-src *;

### CSP Report Request

Надо протестировать работу CSP. 
Для этого при каждом сработанном запрете будет отсылаться отчет в формате json по указанному адресу (report-uri *url*).
В нем есть поля:

- blocked-uri - что заблокировано
- disposition - 'enforce' | 'reporiting' - в зависимости от используемого заголовка
- document-uri - где заблокировано
- effective-directive - нарушенная директива
- original-policy - исходная политика
- referrer - реферер
- script-sample - первые 40 символов документа, спровоцировавшего нарушение
- status-code - статус код страницы 
- violated-directive - нарушенная директива

### Тег base

`<base href="..." target="...">` - HTML тег, определяющий базовый URL, используемый для всех относительных URL.
Может быть только один на весь документ (остальные игнорируются).
Кто-то может вручную поменять base так, что запросы будут идти на сторонний сайт. 
Например, подменить /Account/Login на редирект на http://fuck-you.com/Account/Login, где я заберу твои почту/пароль, а ты не заметишь.

### X-XSS-Protection

X-XSS-Protection - заголовок для остановки загрузки контента при обнаружении XSS атаки.
Значения:

1) 0 - отключить
2) 1 - включить, при обнаружении - удилить небезопасное содержимое
3) 1; mode=block - включить, при обнаружении - предотвратить отображение страницы
4) 1; report=*uri* - включить, при обнаружении - очистить и сообщить (только Chromium)

CSP более функционален, поэтому предпочтительнее, но лишним не будет. Не является частью какой-либо спецификации.

### Cross-Site Request Forgery (CSRF)

Same-Site все равно посылает запрос, хоть не получает ответ. Мы например, можем в параметрах все куки отправить и они сохранятся.

CSRF - тип атаки, использующий такую уязвимость. 

Пример:

На моем сайте slave.cum я делаю `<img src='https://tinkoff.com/transfer?to=slave&amount=1000'>'`.
Затем ты на нее кликаешь, и твои деньги у меня. Так как ты переходишь на сайт и твои куки (то что ты аутентифицирован) отправились тоже.
Со стороны кажется, что ты мне деньги перевел сам.

Защита: 
1. Проверять Referer (не безопасно, можно самим подделать)
2. Посылать вместе с формой секретный ключ

### Double-Submit Cookie Pattern. Валидация Anti Forgery Token

Вариант защиты от CSRF. Клиенту даем 2 токена - один в куках, другой в параметрах ответа (в форме например). 
При получении ответа сверяемся. 
Реализация Stateless, поэтому хорошо масштабируется.

В ASP.NET Core поддержка из коробки для MVC.
```cs
builder.Services.AddMvc(options => 
    options.Filters.Add(new AutoValidateAntiforgeryTokenAttribute()))
```

либо добавляем атрибут `[AutoValidateAntiforgeryToken]` для каждого класса/метода

### Anti Forgery Token в AJAX, WebAPI, SPA

Принцип тот же, только выставление этих токенов, теперь в наших руках. 
На сервере генерируем скрытый токен. В JS находим его, и с запросом добавляем (например в заголовок или параметр)

### Cross Origin Request Sharing (CORS)

Если запрос делается с других сайтов, то могут возникнуть проблемы.
Чтобы их избежать, лучше указывать сайты, которые могут получить к серверу доступ.
Также указываем и методы HTTP, и заголовки (допустимые).

```
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
```

При запросе нужно также указывать, что знаем про CORS. Для fetch: 
```js
await fetch('server.com', {
    mode: 'cors', // no-cors, same-origin, cors
    credentials: 'same-origin', // include, omit, same-origin
})
```

Запросы 3 типов:
1) Простые - нет CORS preflight; GET, HEAD; POST; Content-Type (некоторые типы)
2) Предварительные запросы - запрос методом OPTIONS; PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH

Сначала посылается запрос доступа методом OPTIONS, в котором сервер говорит о методах доступа в заголовках:
- Access-Control-Allow-Origin
- Access-Control-Expose-Headers
- Access-Control-Max-Age
- Access-Control-Allow-Credentials
- Access-Control-Allow-Methods
- Access-Control-Allow-Headers

3) Предварительные запросы и переадресация (устарел и не поддерживается)

### Безопасность кук

Для кук, есть своя безопасность. Для каждой куки можно указать ее свойства:
- Secure - только по HTTPS/SSL
- HttpOnly - недоступны из JS
- Domain - хосты, на которые отсылаются куки
- Path - URL, который должен быть в запрашиваемом ресурсе
- SameSite - когда и как отправлять куки с межсайтовыми запросами, значения - Strict, Lax, None 

### SQL-инъекции.

НЕ ВСТАВЛЯТЬ/ИНТЕРПОЛИРОВАТЬ СТРОКИ В SQL ЗАПРОСАХ!!! ИСПОЛЬЗОВАТЬ ДРУГИЕ МЕТОДЫ:
- Параметризованные запросы: 

```sql
select * from accounts where id = @id;
```
- Проверять/санитизировать строки
- Использовать спец. библиотеки для санитизации, запросов
- Хранимые процедуры

## REST. Web API.

### Что такое web-сервисы

Web-сервис: 
- технология интеграции приложений, которая может использоваться в Интернете
- реализация абсолютно четких интерфейсов обмена данными между различными приложениями, 
которые написаны не только на разных языках, но и распределены на разных узлах сети
- идентифицируемая уникальным веб-адресом (URL-адресом) программная система со стандартизированными интерфейсоми.
- Веб-службы могут взаимодействовать друг с другом и со сторонними приложениями посредством сообщений, 
основанных на определённых протоколах (SOAP, XML-RPC и т. д.) и соглашениях (REST)

### Протоколы веб-сервисов

- XML-RPC
```xml
<?xml version="1.0"?>
 <methodCall>
   <methodName>examples.getStateName</methodName>
   <params>
     <param>
         <value><i4>41</i4></value>
     </param>
   </params>
 </methodCall>
```
- JSON-RPC

```json
{
  "jsonrpc": "2.0",
  "method": "examples.getStateName", 
  "params": [
    41
  ], 
  "id": 1}
```
- SOAP - Simple Object Access Protocol.
*Чаще используется с WSDL (Web Service Description Language) и UDDI (Universal Description Discovery & Integration)*
SOAP - протокол посылки сообщений по HTTP
WSDL - описание интерфейсов сервиса и доступа к нему
UDDI - стандарт индексации описаний сервисов
  - Envelope — корневой элемент, который определяет сообщение и пространство имен, использованное в документе.
  - Header — содержит атрибуты сообщения, например: информация о безопасности или о сетевой маршрутизации.
  - Body — содержит сообщение, которым обмениваются приложения.
  - Fault — необязательный элемент, который предоставляет информацию об ошибках, которые произошли при обработке сообщений.

```xml
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope 
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
        xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
        xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
   <soap:Body>
     <getProductDetails xmlns="http://warehouse.example.com/ws">
       <productID>12345</productID>
     </getProductDetails>
   </soap:Body>
</soap:Envelope>
```

- REST - Representational State Transfer
Это архитектура + принципы построения систем
```http request
POST https://example.com/users/123/posts

PUT https://example.com/images/7
```
  
### Преимущества REST

- Надежность
- Производительность
- Масштабируемость
- Независимое внедрение компонентов
- Способность эволюционировать

### Когда использовать REST

- Надо кешировать
- Ограничения пропускной способности
- Требование масштабирования
- AJAX

### Что такое RESTful

Чтобы быть RESTful, нужно соблюдать ограничения:
1. Client-Server - вся коммуникация это 1-к-1 в виде клиент-сервер. 
Вся сеть поделена на клиентов и серверов.
Если используется взаимодействие на основе событий/сообщений - это не REST.

2. Stateless - сервер не следит за клиентами и не запоминает их. 
Если клиент не обращается - сервер даже о нем не знает.

3. Uniform Interface - общий язык

4. Cache - ответы сервера помечаются - 'кешируемый или нет' 

5. Layered System - может быть большее число слоев, чем клиент и сервер: 
   - Прокси (ретранслирующий, кэширующий)
   - Балансировщик
   - API Gateway
6. Code-On-Demand (не обязательно) - отправка сервером кода (JS) для исполнения у него.

### Принципы единого интерфейса

Uniform Interface достигается через 4 субограничения:
1. Определение ресурсов
Все представлено в виде ресурсов (HTML, изображение, какая-то информация).
Каждый ресурс имеет свой уникальный URI для его идентификации.
   
2. Управление ресурсами через представления
Клиент посылает серверу свое представление (в виде JSON, например) того,
каким он хочет видеть итоговый ресурс.

3. Самодостаточные сообщения
В сообщении содержится все необходимое для его идентификации.
Например, 'Content-Type': 'application/json' если ответ сервера в виде JSON
   
4. HATEOAS - Hypermedia As Engine Of Application State
В сообщении находится также информация о том, 
что с полученным результатом можно делать.
(Обновить его на сервере, это кнопка перехода...)

### HATEOAS с примером

```
HTTP/1.1 200 OK
Content-Type: application/xml

<?xml version="1.0"?>
<account>
    <number>500</number>
    <balance currency='USD'>508</balance>
    <link rel="deposit" href="https://bank.example.com/accounts/123/deposit">
    <link rel="withdraw" href="https://bank.example.com/accounts/123/withdraw">
</account>
```

### Реализация REST

Типичный REST реализуется таким образом:
1. Использование HTTP методов для идентификации действия над ресурсом:
   - GET - получить
   - POST - создать новый
   - DELETE - удалить
   - PUT - заменить
   - PATCH - обновить (частично, некоторые значения)
2. Адрес ресурса передается в URL
3. Представление - в теле запроса (обычно используют JSON)
4. Часто используются HTTP статус коды

### Идемпотентность

При повторении запроса, результат не изменится:
Идемпотентны:
- PUT
- GET
- DELETE (при обращении к ресурсу после DELETE, операции должны возвращать 404)
- PATCH

Не идемпотентны:
- POST

В кратце - все, что безопасно

### HTTP методы

- GET -> 200, 404, 400
`GET https://example.com/users/12`
- POST -> 201 + URI созданного ресурса, 400
`POST https://example.com/users`
- PUT, PATCH -> 200, 204
```
PUT https://example.com/user/12

{
    "name": "Some name"
}
```
- DELETE -> 200, 204
`DELETE https://example.com/users/12`
  
### REST vs SOAP

|                    | REST                              | SOAP               |
|--------------------|-----------------------------------|--------------------|
| Сложность          | Просто                            | Сложно             |
| HTTP               | Просто использует. Не обязательно | Базируется на нем  |
| Формат сообщений   | Любой                             | XML                |
| Ошибки             | HTTP Status Code. Свои            | Стандартизированно |
| Представляет собой | Архитектурный стиль               | Стандарт           |

Use cases:

Rest:
- Сервисы используют JS
- Производительность
- Нет возможности генерации прокси-клиента из сервера

SOAP:
- Есть инструменты ускорения разработки под SOAP
- Можно извлечь пользу из SOAP

### Информирование потребителя

Каждый сервис имеет:
- Поставщика (сервер)
- Потребителя (клиент)

Договор на обслуживание:
- Входы и выходы сервиса (контракт)
- Адрес сервиса (URL)
- Авторизация 

Подходы к созданию: 

|                | Преимущества                   | Недостатки                     |
|----------------|--------------------------------|--------------------------------|
| Contract first | Параллельная разработка        | Начальные затраты              |
|                | Результат предвиден            | Трудности обновления контракта |
|                | Кроссплатформенность           |                                |
|                | Повторное использование схем   |                                |
| Code first     | Минимальные начальные усилия   | Не параллельно                 |
|                | Синхронизация кода и контракта | Нет цели                       |
|                |                                | Нет кроссплатформенности       |


### Безопасность – уязвимости

TOP 10 OWASP (Open Web Application Security Project):
1. Broken Access Control
2. Cryptographic failures
3. Injection
4. Insecure design
5. Security misconfiguration
6. Vulnerable and outdated components
7. Identification and Authentication failures
8. Software and Data integrity failures
9. Security logging and monitoring failures
10. Server Side Request Forgery

### Безопасность – аутентификация

Аутентификация может быть несколькими способами:
- API Key
- HTTP Authorization: `Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=`
- Cookie: `Set-Cookie: Session=asDFAWv12; HttpOnly; Path=/`,
- Token based: `Authorization: Bearer asdfaDfadSFa12sdfFEH9`

### Алгоритм Token-Based

В кратце - OAuth, OpenID Connect:
1. Захожу на сайт
2. Кликаю 'Войти через Google'
3. Перехожу на сайт Google Accounts
4. Ввожу почту/пароль (если не вошел)
5. Подтверждаю передачу прав сайту
6. Сайту дается Access Token
7. Сайт обменивает его на Refresh/Access token
8. С каждым запросом отдает Access token серверу

### Недостатки контроля доступа к объектам

- Проверка доступа при каждом запросе 
- Подбор сложных ID

### Небезопасная десериализация

При десериализации лишняя информация может затереть существующую.
1. На Node.js приходит объект
2. Мы его не проверяем, не мапим - используем то, что пришло
3. Проверяем необходимые нам данные
4. Обновляем этим объектом MongoDB
5. Вуаля!! Мы перетерли ID, добавили новые поля и т.д.

### Отсутствие проверок и ограничений

Для каждого сервиса - устанавливать ограничения:
- Максимальное количество попыток входа
- Блокирование IP при подозрительных операциях
- Ограничение числа запросов за определенное время (за 1 мин макс 60 запросов)

### Недостатки управления API

- Слежение за версией, назначением API, списком имеющих доступ
- Поддержка старых API
- Открытые - только актуальные версии
- Ограничить доступ только открытыми точками (закрыть доступ отладочных/привилигированных endpoints)

### REST API Best Practices

1. Конечные точки - существительные, а действия - HTTP метод
`GET /api/v1/users`
2. Существительные во множественном числе
3. Использование действующих стандартов документации
   - Swagger
   - OpenAPI
   - Apiary
   - DRF Docs
4. Версионирование (добавить v1, v2.1 и т.д.)
5. Использовать заголовок типа получаемого результата `Accept: application/xml`
6. Везде где множественное получение - пагинация
7. Защищенное соединение (TLS, SSL, HTTPS)
8. Использовать HTTP статус коды, для различных операций
   - 200 - Все ОК
   - 204 No Content - при удалении/обновлении
   - 304 Not Modified - кэширование
   - 405 Method Not Allowed - для тебя только чтение (GET), админ может еще и писать (POST)
   - 401 Unauthorized - Не аутентифицировался
   - 403 Forbidden - Нет прав (не тоже самое, что 401)
   - 429 Too Many Requests - Превышено макс кол-во запросов

### Введение в Web API

WebAPI - надстройка над MVC для создания RESTful приложений.

### Приложение

- Проект Web с шаблоном WebAPI
- Контроллеры без представления
`builder.Services.AddControllers();`
- Маршруты - автоматически (можно настроить)
`app.MapControllersRoute();`

### Атрибуты

1. `[ApiController]` - для класса контроллера.
Автоматически валидирует DTO и возвращает 400 при неправильных моделях.
2. `[Http{Get|Post|Delete|Put|Patch}(route)]` - endpoint для контроллера. 
Для одного и того же метода, может быть несколько endpoints. 
3. `[Route(route)]` - для методов (тогда HTTP метод не важен) и класса (базовый путь контроллера)

### Тестирование

Сторонние программы:
- Postman
- Insomnia
- Fiddler
  
Через консоль:
- cURL
- Invoke-RestMethod (PowerShell)


### Статусы

В REST принято по максимуму использовать HTTP Status Codes.
Для каждого варианта ответа - дать максимально специфичный статус.

### Возвращаемое значение в ASP.NET Core

Формат возвращаемого значения определяется фреймворком.
Зависит от:
- Принимаемого типа контента клиента
- Поддерживаемые форматы генерации
- Политики формирования ответа

Сам метод может возвращать:
- Конкретные типы: int, string, object + пользовательские классы
- IActionResult - общий интерфейс возвращаемого значения.
Есть только метод `Task ExecuteResultAsync(ActionContext)`
- ActionResult<T> - тот же IActionResult, только типизированный

### IActionResult

Интерфейс представляющий ответ.
От него наследуются многие базовые типы ответов:
- OkResult
- ObjectResult
- RedirectResult
- BadRequestResult
- NotFoundResult
- JsonResult

### Content negotiation

Получаемый клиентом ответ, должен быть понят.
Для этого есть заголовок 'Content-Type'.
Соглашения:
- Базовые типы (int, string, DateTime...) - превращаются в строку
- Объекты, отправляемые через ObjectResult, сериализуются (JSON по умолчанию)

### Accept

Клиент может сам указать, в каком типе хочет получить результат.
Для этого отправляется заголовок 'Accept'.
Через ';' указываются поддерживаемые типы.

`Accept: text/html,application/xml,image/jpeg,video/*` - HTML, XML, изображения только jpeg, все форматы видео.

### xml - возвращаемое значение

Для лучшей поддержки XML, в пайплайне для MVC нужно указать  XML сериализатор:
```csharp
builder.Services.AddMvc()
                .AddXmlDataContractSerializerFormatters();
```

При получении от клиента `Accept: application/xml`, результат автоматически сконвертируется в XML.

### Аутентификация – JWT

JWT (JSON Web Token):
- Header - тип токена + алгоритм его шифорования
- Payload - данные для авторизации
- Signature - хэш из Header и Payload, для верификации токена

### JWT – сервисы и конвеер

Для добавления поддержки JWT - добавить JWT в аутентификацию:
```csharp
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
                .AddJwtBearer(jwt => 
                    {
                        jwt.RequireHttpsMetadata = true;
                        jwt.TokenValidationParameters = new TokenValidationParameters() { ... };
                    });
```

### JWT – генерация токена

С помощью готовых библиотек/фреймворков:
- OpenIddict
- IdentityServer

Вручную:
- JwtSecurityToken - информация о токене
- JwtSecurityTokenHandler - для создания токена (метод WriteToken)

### Swagger / OpenAPI

Фреймворк для спецификации API.
Целая экосистема: спецификация, UI, готовые фреймворки для различных языков (Swashbuckle)

### Обработка ошибок.

В зависимости от среды можно проставить различные обработчики ошибок.

```csharp
if (app.Environment.IsDevelopment())
    app.UseExceptionHandler("/error-dev");
else
    app.UseExceptionHandler("/error");
```

Для различных сред - разные обработчики соответственно.

## Микросервисная архитектура

### Общее описание

Берем всю систему.
Разбиваем ее на отдельные секции по ответственности (платеж, доставка, товары, чат...).
Для каждой системы создаем отдельное приложение.
Они будут взаимодействовать между собой.
Приложение = взаимодействующие между собой такие маленькие сервисы (микросервисы).

Как правило каждый для специфичной проблемы.

### Сравнение с монолитом

В монолите вся логика в одном процессе.
Приложение - на одном сервере.

### Проблемы монолита

- Изменение в 1 месте - сборка и развертывание ВСЕЙ системы.
- Масштабирование - вертикальное (мощнее hardware).
- Модульность - проблема

### Преимущества микросервисов

- Горизонтальное масштабирование (большее кол-во серверов)
- Независимая/параллельная разработка
- Четкие границы с поделенной ответственностью
- Гетерогенная система - работа на различных языках, в различных средах.

Одна часть на TS + Node.js, другая на C# + ASP.NET Core, третья на python + flask

### Принципы проектирования

- High Cohesion - высокая связНость (сплоченность) (сервисы объединены для решения каждая своей задачи)
- Autonomous - слабая связАННость, автономность (каждая система независима от остальных, использует только предоставленный API)
- Business Domain Centric - сфокусироваться на своей задачей (свой ограниченный контекст (DDD))
- Resilience - отказоустойчивость
  - система должна быть хорошо защищена 
  - отказ - нормальное явление
  - параноидальная разработка(нас хотят постоянно взломать - проверять все)
- Observable - можно посмотреть, что происходит внутри нее (логи, состояние)
- Automation - система должна быть такой, чтобы рутинные задачи выполнялись просто
  - Тестирование
  - Развертывание (замена строки подключения через переменные окружения, чтобы при запуске просто указать, а не перекомпилировать)

### Минусы микросервисной архитектуры

- Сложность (много взаимодействующих частей)
- Разработка + тестирование (специфический подход)
- Нет централизированного управления
- Сеть (нестабильность, задержки)
- Целостность (ограничимся Eventual Consistency)
- Управление (придется жонглировать несколькими приложениями)
- Версионирование (поддержка старых, добавление новых)

### Реализация архитектуры

1. Модули
   - Отдельные приложения (ASP.NET Core WebAPI)

2. Слабая связанность
   - Взаимодействие сервисов между собой через API
   - Консистентность только в рамках своих обязанностей (можно использовать API Gateway, BFF)
   
### Взаимодействие микросервисов

Может быть 2 видов:
- Синхронное (RPC, gRPC, HTTP)
- Асинхронное (посылка сообщений, публикация событий)

### Взаимодействие в .Net

- HTTP - инъектируем HttpClient, используем HttpClientFactory
- gRPC - фреймворк для вызова функций на другом сервисе
- RabbitMQ - брокер сообщений (очередь)

### Слабая связанность

Практически не должно быть зависимости между сервисами, иначе лучше объединить в один.
Исключение - сквозная функциональность (Модели, БД (для каждого сервиса лучше отдельную))

### Отказоустойчивость

Проектирование системы должно быть с учетом недоступности сервиса.
Если он недоступен, то нужно откатить транзакцию и исправить, что сделано.
Либо сделать запрос к сервису еще раз.

Для повторных запросов, подходит стратегия экспоненциального времени ожидания:
не получилось - ждем (номер попытки)^2 до максимального числа попыток, если не получилось, то откат.

### API Gateway

У нас может быть много микросервисов.
Каждый со своей спецификой работы.
Чтобы абстрагировать пользователя от сложности нашей системы введем дополнительный слой,
в котором определим простой и понятный API. 
Внутри этого API будет логика, координирующая работу микросервисов.

У него может быть большая функциональность:
- Аутентификация
- Авторизация
- Балансировка нагрузки
- SSL terminating
- Аггрегация
- Кэширование

Также можно для каждого типа клиента (web, mobile, desktop) сделать свой отдельный API Gateway (паттерн BFF, Backend for Frontend).

### Легкая заменяемость

Мы должны быть способны заменить наш старый инстанс на новый так,
чтобы пользователь этого не заметил. 
Причины замены:
- Новая версия api + поддержка старых версий
- Восстановление после ошибки
- Обновление системы

Для этого все сервисы должны быть обособлены друг от друга,
чтобы изменения в 1 части не затронуло другую часть.

### Наблюдаемость

В рамках работы нам нужно:
- Получать состояние сервиса (Health Check)
- Смотреть, что с ним происходит (Логирование)

Можно завести централизированный сервис мониторинга.
Все логи будут отправлятся в это место. 
Также место сбора данных должно быть обособлено от самих сервисов: 
- Получение примерно реальных (похожих на клиентские) результатов
- Если сервис упадет, то это мониторинг не затронет

### Health Check

Health check - проверка доступности сервиса. 

Обычно endpoint `health` просто отдает '200 OK' - сам сервис доступен, 
т.к. если он не доступен, то мы все равно получим ошибку подключения (или что-то типа того).

Можно настроить проверку и для отдельных частей приложения.
Например, по `health/db` проверять доступность базы данных.

### Логгирование

Логирование:
- В ASP.NET Core можно настроить как (уровень логирования, форматирование) и куда (файл, консоль...) будет все логироваться
- Для сбока логов - отдельный аггрегирующий сервис
- Лучше не логировать в файл, а отсылать в отдельный сервис (после удаления контейнера - файл удалится)
