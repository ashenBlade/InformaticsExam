# Вопросы по информатике

## Введение в ASP.NET Core

### Понятие фреймворка

Фреймворк - карскас, определяющий структуру ПО. Облегчает разработку и объединение различных программных компонентов.
Диктует правила построения архитектуры приложения

### Особенности фреймворков

Библиотека, в отличие от фреймворка, предоставляет функциональность и не влияет на архитектуру.

### ASP.NET Core

ASP.NET Core - свободно-распространяемый кроссплатформенный фреймворк для создания веб-приложений на платформе .NET с открытым исходным кодом.
Построен на новом веб-стеке, но при этом обладает высокой степенью совместимости с ASP.NET.
Совмещает несколько моделей разработки: базовый (минимальные необходимые требования - middleware, routing, configuration), MVC, Razor Pages (надстройка над MVC), WebAPI, Blazor

### Свойство кросс-платформенности. Преимущества

Кросс-платформенность позволяет создавать WORA приложения (write once run anywhere). Мы можем написать общий код, описывающий общую функциональность, а затем запускать его на разных машинах, на разных ОС и т.д. Преимущества:

- Уменьшение времени разработки
- Сокращение расходов
- Единая кодовая база
- Покрытие более широкой аудитории
- Одинаковый UI/UX

### Запуск и настройка приложения

Приложение запускается из Main. Через метод статического класса WebApplicationBuilder.CreateBuilder() мы получаем объект WebApplicationBuilder, в котором определяем настройки нашего приложения: конфигурация, логирование, окружение, зависимости и т.д.

Когда настройка завершена, создаем само приложение, вызывая метод Build(). Полученный объект - наше приложение, которое и нужно запустить.

### Запуск

WebApplicationBuilder builder = WebApplication.CreateBuilder();
WebApplication app = builder.Build();

### Паттерн Builder

Builder - один из порождающих паттернов GoF. Позволяет создавать крупные составные объекты. Хорошо работает с FluentAPI.

Пример, когда есть значения по умолчанию, а нам нужно создать объект, в котором изменяется только 1 аргумент в конструкторе.

### Program и StartUp, как с этим в .NET 6

В .NET 6 убрали необходимость в отдельном классе StartUp. Его 2 основных метода теперь можно реализовать прямо в методе Main (начиная с C# 10 (вроде), метод Main не нужно явно реализовывать). Теперь все можно сделать в 1 методе - сначала ConfigureServices, затем Configure.

### HostBuilder. WebApplicationBuilder

HostBulider - **общий** класс для построения хостов.

WebApplicationBuilder - класс для постоения хостов преимущественно **HTTP(S)**.

В кратце, HostBuilder создает IHost (для любых подключений), WepHostBuilder создает IWebHost (для веб серверов). IHost может быть каким-нибудь клиентом Postgres (он http не принимает), IWebHost - наш веб-сервер. По умолчанию, в шаблоне Web используем IWebHost с WebHostBuilder.CreateBuilder(args)

### Content & Web root path

ContentRootPath - путь до файлов самого приложения (dll, exe)

WebRootPath - путь до файлов, обрабатываемых запросами (wwwroot по умолчанию)

Оба: абсолютные (с корня), задаются в IWebHostEnvironment, для каждого свой FileProvider

### Окружения

Нужны для корректной работы, передачи важных переменных (строки подключения, пароли, кол-во подключений в пуле и т.д.). Источники задаются в ConfigurationManager объекта IWebHostBuilder. 

Значения окружения могут быть получены из:

- файлов (launchSettings.json, web.config)
- переменных окружения (ASPNETCORE_URLS)
- задаваться вручную (AddInMemoryCollection(IEnumarable\<KeyValuePair\>))

### launchSettings.json

Настройки приложения могут быть получены из файла. По умолчанию в папке проекта ищется файл launchSettings.json, в котором в формате json определены настройки для проекта. 

Также в зависимости от типа кружения (Production, Developement ...) могут быть загружены специфичные настройки. Спец. настройки указываются в файле launchSettings.{Environment}.json (launchSettings.Development.json). Указанные в них значения перетирают launchSettings.json (если присутствуют)

### Класс Startup (.NET Core 3.x/5)

До .NET 6 для настройки сервисов и пайплайна обрабоки использовался класс специальный класс (StartUp по умолчанию), в котором должны быть опеределны 2 метода - ConfigureServices, Configure. В первом методе добавлялись сервисы необходимые для функционирования, во втором настраивался порядок обработки запроса (Pipeline).

### Настройка приложения в .NET 6

Начиная с .NET 6 необходимость в этом классе ушла и все необходимые манипуляции можно произвести в основном методе Main. Сначала создаем Builder, его настраиваем. Затем вызываем Build(), получаем  объект WepApplication. В нем настраиваем конвеер обработки (UseRouting, UseAuthorization...). В конце вызываем Run().

### Dependency Inversion Principle

Идея такая - вам нужен не сам класс, а его функциональность. Нам нужен не человек, а что-то, что может перетаскать коробки, а это могут быть робот, человек, магия и т.д. В таком случае, мы определяем ЧТО нам нужно, выделяем это ЧТО-ТО в отдельный интерфейс, и на основе этого делаем реализацию.

> Мы должны зависеть от абстракции, а не от реализации

### Сервисы

Сервис (англ. Service - обслуживать) - это что-то, что выполняет какую-то функциональность. Например, шлет email, логирует и т.д. 

Хорошо согласуется с [Dependency Inversion Principle](#dependency-inversion-principle) - в конструктор передаем выделенные интерфейсы.

### Инъекция зависимостей (зачем)

Инъекция зависимостей - паттерн, при котором мы передаем не сами классы с реализацией, а их интерфейсы (см. [Depency Inversion](#dependency-inversion-principle)). 

Зачем:

- динамчески заменять реализацию (в зависимости в от состояния подключения либо в памяти, либо в файл, либо в бд сохранять изменения)
- для тестов (заменяем на моки, стабы, фейки)

### IoC контейнеры

IoC container (IoC - Inversion of Control) - контейнер (объект) содержащий в себе все необходимые сущности. Сам выстраивает граф зависимостей для создания, определяет что нужно и т.д. В ASP.NET Core из коробки есть свой, но можно заменить на другие (Autofac ...)

### Инъекция в Startup (.NET Core 3.x/5)

В .NET Core 3.x/5 должен быть метод StartUp, котором есть методы ConfigureServices, Configure (см. [Класс StartUp (.NET Core 3.x/5)](#класс-startup-net-core-3x5)). Иногда нам нужно определить в каком окружении мы исполняемся - тест или прод. В таком случае мы можем пробросить зависимости в конструктор (или сам метод (уточнить!)). 
Например, IWebHostEnvironment.

### Замена контейнера. Замена на autofac

Замена контейнера производится как обычная замена сервиса - только заменить дескриптор. 

Пример для Autofac:

```cs
var host = new WebHostBuilder()
        .UseKestrel()
        .ConfigureServices(services => services.AddAutofac()) // Здесь заменяем
        .UseContentRoot(Directory.GetCurrentDirectory())
        .UseIISIntegration()
        .UseStartup<Startup>()
        .Build();

    host.Run();
```

Замена работает и для общего хоста IHost:

```cs
var host = Host.CreateDefaultBuilder(args)
        .UseServiceProviderFactory(new AutofacServiceProviderFactory())
        .ConfigureWebHostDefaults(webHostBuilder => {
          webHostBuilder
            .UseContentRoot(Directory.GetCurrentDirectory())
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
```

### Доступ к сервисам

Доступ к сервисам происходит:

- Автоматически с помощью DI контейнера через внедрение зависимосетей(конструктор, свойства(не рекомендуется), аргументы методов(new!!!!))
- Внедрить DI контейнер напрямую и разрешать самому

```cs
var service = _container.GetRequiredService<ISomeService>();
```

### Middleware

Middleware - ПО промежуточного слоя. Выстраивается в виде обработчика на конвеере запроса. Алгоритм такой:

1. Получаю запрос
2. Что-то с ним делаю
3. Решаю пускать ли его дальше или нет
4. Пускаю или возвращаю
5. Если пускаю, то могу обработать его еще раз на обратном пути

Настраивается после метода Build()/в методе Configure класса StartUp.
Для настройки используются методы Map, Use, Run

[Docs](https://docs.microsoft.com/ru-ru/aspnet/core/fundamentals/middleware/?view=aspnetcore-6.0)

### Методы Use и Run

Use:

- Метод расширения
- Создание цепочки обработки
- Принимает Func\<HttpContext, RequestDelegate, Task\>: (context, next) -> Task

Run:

- Конечная точка обработки
- Принимает RequestDelegate: (context) -> Task
- Если ничего не передавать - запускает приложение

### Методы Map и MapWhen

[Даже название не изменил](https://metanit.com/sharp/aspnet5/2.22.php)

Map:

- Сопоставляет путь с текущим и если совпал то переходит по требуемому пути исполнения
- Получает строку для сопоставления и builder (т.е. для каждого совпадения отдельный конвеер обработки)

MapWhen:

- Как Map, но с условием

### Создание компонент middleware

Создание:

- Middleware - класс с методом InvokeAsync(HttpContext context, RequestDelegate next)
- Есть интерфейс IMiddleware (не обязательно)
- Добавление в пайплайн - UseMiddleware\<TMiddleware\>()
- Можно создать свои кастомные UseXXX

### Статические файлы

Для обработки статических файлов есть middleware UseStaticFiles. Файлы ищутся по пути WebRootPath из объекта WebHostEnvironment.

### Конвейер обработки запроса

Последовательно добавляем свои Middleware в конвеер. При старте конвеер собирается, а при получении запроса передается в конвеер. Каждый middleware при получении решает что с ним делать: добавляет в ответ какие-то данные, проверяет заголовки, логирует и т.д. Дальше запрос может не передать (UseAuthentication, UseStaticFiles). Последний в конвеере из Use - Run. Он дальше не передает - конечная точка. 
Также для MVC есть свой отдельный пайплайн из фильтров: ResourceFilter, ExceptionFilter, AuthrizationFilter и другие.

### Время жизни middleware

Middleware живет все время существования приложения - singleton.
Поэтому, для внедрения зависимостей transient, scoped лучше использовать внедрение через метод.

### Ведение журнала

Поддержка логирования - встроенная. Для этого есть даже отдельное свойство - Logging.
Логирование может осуществляться во множество путей: файл, консоль, даже сеть.
Есть поддержка уровней логирования:

- None - не логировать
- Debug - для дебага (например, занчения переменных)
- Trace - для трассировки выполнения (например, отслеживать какой метод вызвался)
- Information - главная логика приложения (например, что заказ выполнен, пользователь зарегистрировался)
- Warning - ошибки, не влияющие на выполнение приложения (например, отправка email не работает)
- Error - ошибки, которые влияют на корректное исполнение приложения и должны быть обработаны (например, бд недоступна)
- Critical - пиздец (например, переполнение бд, недостаток памяти)

Для логирования есть метод Log() и его расширения LogInformation и т.д.

Интерполяцию лучше не делать, а передавать аргументы позже (т.к. интерполяция стоит время, а если просто передавать аргументы, то она отложенная)

### Обработка ошибок

Ошибки есть 2 типов - сервера и логики (Exceptions и те, что должны вернуть HTTP 4xx статус).
Если это 2 - то, все ок возвращаем статус (+ страница если нужно).

Если это 1 - то, все плохо. Разработчик, должен понять, что произошло (UseDeveloperExceptionPage), а пользователь не должен такое увидеть (UseExceptionHandler)

В обоих случаях нужно логировать.

### Публикация в Azure

На Azure публикация проста - в Visual Studio кликаем на Publish, выбираем Azure, вводим свои данные, план, место и т.д. и публикуем. (Он вроде сам там скомпилирует(проверить!!))

## ASP.NET Core. Publish & Deploy

## Модель хостинга ASP.NET Core


Reverse proxy
Run ASP.NET Core app
Публикация
Запуск опубликованного приложения
dotnet command
Независимый деплой
Как деплоить
CI
CD
Развёртывание в IIS
Пул приложений
Поддержка в коде
Middleware
web.config
Хостинг приложений под Linux
Run ASP.NET Core app on Linux
app & reverse proxy on different servers
ASP.NET Core in Docker
Docker
Потенциальные проблемы при деплое
Разница между Linux и Windows
Конфигурирование
Бандлинг/минификация

3. ASP.NET Core. Middleware

Обработка запроса
HttpContext
HttpRequest
HttpResponse
Middleware
Примеры
Middleware Pipeline
Выстраивание конвейера
Методы Use, Map, Run, MapWhen
Проблема с формированием ответа
Кастомные компоненты Middleware
Дополнительные параметры
Порядок вызова
Middleware обработки ошибок
Middleware vs Services
Маршрутизация в ASP.NET Core
Конечные точки
Шаблоны маршрутов
Маршрутизация - Концепции
Совпадение маршрутов
Генерация URL-адресов
Обработка ошибок
Обработка ошибок HTTP: UseStatusCodePagesWithRedirects vs UseStatusCodePagesWithReExecute
Использование Cookie
Сессии

4. ASP.NET Core. Services & DI

Сервисы - зависимости
Пример зависимости
Проблемы прямых зависимостей
S.O.L.I.D
ServiceLocator
DI анти-паттерны
IoC (Inversion of Control)
Свой тривиальный контейнер
IServiceProvider
Регистрация сервисов
IServiceCollection Extension methods
Время жизни
Варианты регистрации
Общая схема работы
Типичные ошибки с Lifetime
Резолв из transient сервиса scoped или singleton зависимостей
GetService<TService>()
Несколько сервисов или интерфейсов
Рекомендации по созданию сервисов
Disposal of services
Рекомендации по использованию сервисов

5. Архитектура приложений ASP.NET Core MVC

Монолитное приложение
All-in-one приложения
Слои приложения
Правильные зависимости
Чистая архитектура
Распределение по слоям
Ядро приложения - Бизнес-логика
Типы данных ядра приложения
Инфраструктура - Доступ к данным
Типы данных слоя инфраструктуры
Repository pattern
Generic Repository
Инъекция Repository
Unit of Work
Repository и UoW в .NET
Уровень пользовательского интерфейса
Типы данных UI
UI ASP.NET Core
ASP.NET Core MVC / Razor Pages
Model / ViewModel
Контроллеры
Действия (action)
IActionResult
IActionResult: redirect
Валидация модели
Представления
Razor
Передача данных в представления
Вспомогательные функции тегов
Скаффолдинг
Маршрутизация
Атрибуты маршрутизации
ControllerContext
Передача параметров в запросе
model binding, массивы/объекты
Загрузка файлов
Работа с файлами - Безопасность
Инъекции зависимостей

6. ASP.NET Core Auth*

Фильтры MVC
Виды фильтров
Создание фильтров
Добавление фильтров
Identification / Authentication / Authorization
Способы аутентификации
По сертификатам
По одноразовым паролям
По ключам доступа
Аутентификации по паролю
HTTP authentication
Forms authentication
URL query
Request body (POST, PUT, PATCH)
HTTP header
Аутентификация по паролю - Уязвимости
Аутентификация по токенам
Форматы токенов
Аутентификация в ASP.NET Core
HttpContext.User
ClaimsPrincipal
Claims vs Roles approach
Процесс аутентификации
Middleware
Добавление в обработку
Задачи аутентификации
Схема аутентификация
Создание аутентификационной куки
Удадение и обновление куки
ASP.Net Core Identity
Возможности Identity
Кастомизация Identity
Сервисы Identity
Настройка Cookie для Identity
Identity’s database schema
Сервисы
Кастомизация пользователей
Кастомные claims
Simple Authorization
Авторизация по ролям
Authorization Policy
Добавление политики авторизации
Ограничения политик (методы)
RequireAssertion(handler)
Пример авторизации
Пример своего ограничения
Обработчик своего ограничения
Регистрация своего ограничения
Использование контекста MVC
Resource-based authorization
Включение в представления.

## ASP.NET Core. Security

### SSL

SSL (Secure Socket Layer) - криптографический протокол, для более безопасной связи. 
Шифрование происходит над HTTP трафиком. 

- Ассиметричное шифрование - обмен ключами
- Симметричное шифрование - сохрание конфиденциальности
- Коды аутентификации - целостность сообщений

Принцип работы:
1. Клиент шифрует открытым ключом сообщение
2. Сервер дешифрует принятое сообщение приватным

И наоборот

### Сертификаты

Сертификат - спец. документ, удостоверяющий что у владельца есть опеределенные права. 
В случае с криптографией (TLS, SSL) это файл формата X.509, в котором содержится информация о:

- Имени, адреса держателя, названия организации
- Открытый ключ
- Дата проверки сертификата
- Серийный номер серитфиката

Используется для установления защищенного соединения при подключении. 
Хранится на сервере в определенной директории. 


### Атака Open Redirect. Защита

В URL может быть прописан адрес *redirectUri*, который ведет на совершенно другой сервер.
Например, после авторизации может быть редирект ссылка на вредоносный сайт, тогда при получении такого запроса
хакер знает, что запрос пришел с такого адреса и попытается получить данные аккаунта.

Шаблон параметра: redirectUrl, returnUrl, return-url, redirect-url 

Для защиты необходимо не просто проверять, что параметр returnUrl присутствует, 
но и валидировать его хост (DNS имя сервера), 
чтобы возврат происходил на тот же адрес

### Защита данных

Секреты приложения должны быть доступны только авторизованным пользователям.
Чтобы ограничить доступ к ним можно:

- Шифровать весь проходящий трафик
- Хранить важные данные только в зашифрованном виде
- Не хранить критические данные в общедоступном месте (не в репозитории, например)

### Шифрование данных (CryptoAPI)

Чтобы данные были защищены, их нужно зашифровать. 
Из коробки есть интерфейс IDataProtector у которого есть метод Protect: byte[] -> byte[], string -> string 

### Установка времени жизни

Для некоторых типов данных нужно уметь хранить их определенное время.
У IDataProtector есть метод ToTimeLimitedDataProtector.
Он может установить период валидности зашифрованных данных. 

### Хранение паролей

Пароли хранить только в шифрованном виде!
Использовать криптостойкие алгоритмы и желательно пройти по несколько раз.
Также стоит добавить к ним соль, чтоб уж наверняка.

### Настройка криптографии

Настройка криптографии в ASP.NET Core - также как и остальные сервисы.
Есть встроенная криптография: 
```cs
builder.Services.AddDataProtection()
                .SetDefaultKeyLifetime(TimeSpan.FromMinutes(30));
```

### Клиентские уязвимости

- XSS, Cross Site Scripting
- L/RFI, Remote/Local File Include
- JSON Injection
- XEE, XML extenal entity
- ClickJacking

### Same-origin policy (SOP)

SOP - политика, определяющая как документ или скрипт, 
загруженный из одного источника может взаимодействовать с ресурсом из другого источника.
Изоляция потенциально вредоносных документов.
В кратце, запись - разрешена, чтение - нет (не везде, например, между iframe ничего cross-origin) 

### Что такое Origin

Origin = scheme + host + port.
Поменяешь хоть что-то одно - это другой Origin.

- http != https
- 80 != 443
- app.domain.com != app2.domain.com
- http://vk.com:20 == http://vk.com:20/me
- https://github.com != https://github.com:444

### Суть XSS. Пример

Нельзя с другого Origin просто так получить контент/сделать запрос. 
Для доступа с других Origin нужно выставить CORS заголовок.

Пример:
1. Захожу на рандомный сайт.
2. Оставляю коммент, в котором есть скрипт
3. Этот скрипт отправляет GET запрос на мой сервер, в котором есть все куки
4. Среди кук я нахожу твой Access/Refresh token
5. Через время запускаю DDoS на Яндекс
6. Виноват ты (формально)

### Как предотвратить инъекции

Нужно:
1. Валидировать/фильтровать входные данные
2. Санитизировать (экранизировать, например) выходные данные

### Валидация и фильтрация. Санитизация. Общие правила. Razor

- Фильтрация предпочтительнее по белым спискам ("всем кому можно", а не "всем, кроме")
- Используем специальные политики для каждого запроса (страна, возраст, пасспорт и т.д.)
- Не размещать недоверенные данные во входе
- Профильтровать каждый вход URL/HTML/JS
- Razor автоматически санитизирует HTML

### Content Security Policy (CSP)

Content Secure Policy - политика, определяющая из каких источников можно получать контент (скрипты, css, html ...).
В ответе сервера выставляется заголовок Content-Security-Policy, в котором выставляются специальные директивы использования. 
Обязательно нужно включать default-src (fallback).

Примеры применений (атрибуты для выставления):
- Только с сервера: default-src 'self'
- Только с сервера и доверенного источника: default-src 'self' *.trusted.com
- Только сервера, но если пользователь вставит медиа, то с разрешенных: default-src 'self'; img-src *; media-src trusted-media.com; script-src static.domain.com
- Весь получаемый контент по SSL: default-src https://some-address.com
- Изображения из любых источников, но запретить JS: default-src 'self' site.com; img-src *;

### CSP Report Request

Надо протестировать работу CSP. 
Для этого при каждом сработанном запрете будет отсылаться отчет в формате json по указанному адресу (report-uri *url*).
В нем есть поля:

- blocked-uri - что заблокировано
- disposition - 'enforce' | 'reporiting' - в зависимости от используемого заголовка
- document-uri - где заблокировано
- effective-directive - нарушенная директива
- original-policy - исходная политика
- referrer - реферер
- script-sample - первые 40 символов документа, спровоцировавшего нарушение
- status-code - статус код страницы 
- violated-directive - нарушенная директива

### Тег base

`<base href="..." target="...">` - HTML тег, определяющий базовый URL, используемый для всех относительных URL.
Может быть только один на весь документ (остальные игнорируются).
Кто-то может вручную поменять base так, что запросы будут идти на сторонний сайт. 
Например, подменить /Account/Login на редирект на http://fuck-you.com/Account/Login, где я заберу твои почту/пароль, а ты не заметишь.

### X-XSS-Protection

X-XSS-Protection - заголовок для остановки загрузки контента при обнаружении XSS атаки.
Значения:

1) 0 - отключить
2) 1 - включить, при обнаружении - удилить небезопасное содержимое
3) 1; mode=block - включить, при обнаружении - предотвратить отображение страницы
4) 1; report=*uri* - включить, при обнаружении - очистить и сообщить (только Chromium)

CSP более функционален, поэтому предпочтительнее, но лишним не будет. Не является частью какой-либо спецификации.

### Cross-Site Request Forgery (CSRF)

Same-Site все равно посылает запрос, хоть не получает ответ. Мы например, можем в параметрах все куки отправить и они сохранятся.

CSRF - тип атаки, использующий такую уязвимость. 

Пример:

На моем сайте slave.cum я делаю `<img src='https://tinkoff.com/transfer?to=slave&amount=1000'>'`.
Затем ты на нее кликаешь, и твои деньги у меня. Так как ты переходишь на сайт и твои куки (то что ты аутентифицирован) отправились тоже.
Со стороны кажется, что ты мне деньги перевел сам.

Защита: 
1. Проверять Referer (не безопасно, можно самим подделать)
2. Посылать вместе с формой секретный ключ

### Double-Submit Cookie Pattern. Валидация Anti Forgery Token

Вариант защиты от CSRF. Клиенту даем 2 токена - один в куках, другой в параметрах ответа (в форме например). 
При получении ответа сверяемся. 
Реализация Stateless, поэтому хорошо масштабируется.

В ASP.NET Core поддержка из коробки для MVC.
```cs
builder.Services.AddMvc(options => 
    options.Filters.Add(new AutoValidateAntiforgeryTokenAttribute()))
```

либо добавляем атрибут `[AutoValidateAntiforgeryToken]` для каждого класса/метода

### Anti Forgery Token в AJAX, WebAPI, SPA

Принцип тот же, только выставление этих токенов, теперь в наших руках. 
На сервере генерируем скрытый токен. В JS находим его, и с запросом добавляем (например в заголовок или параметр)

### Cross Origin Request Sharing (CORS)

Если запрос делается с других сайтов, то могут возникнуть проблемы.
Чтобы их избежать, лучше указывать сайты, которые могут получить к серверу доступ.
Также указываем и методы HTTP, и заголовки (допустимые).

```
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
```

При запросе нужно также указывать, что знаем про CORS. Для fetch: 
```js
await fetch('server.com', {
    mode: 'cors', // no-cors, same-origin, cors
    credentials: 'same-origin', // include, omit, same-origin
})
```

Запросы 3 типов:
1) Простые - нет CORS preflight; GET, HEAD; POST; Content-Type (некоторые типы)
2) Предварительные запросы - запрос методом OPTIONS; PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH

Сначала посылается запрос доступа методом OPTIONS, в котором сервер говорит о методах доступа в заголовках:
- Access-Control-Allow-Origin
- Access-Control-Expose-Headers
- Access-Control-Max-Age
- Access-Control-Allow-Credentials
- Access-Control-Allow-Methods
- Access-Control-Allow-Headers

3) Предварительные запросы и переадресация (устарел и не поддерживается)

### Безопасность кук

Для кук, есть своя безопасность. Для каждой куки можно указать ее свойства:
- Secure - только по HTTPS/SSL
- HttpOnly - недоступны из JS
- Domain - хосты, на которые отсылаются куки
- Path - URL, который должен быть в запрашиваемом ресурсе
- SameSite - когда и как отправлять куки с межсайтовыми запросами, значения - Strict, Lax, None 

### SQL-инъекции.

НЕ ВСТАВЛЯТЬ/ИНТЕРПОЛИРОВАТЬ СТРОКИ В SQL ЗАПРОСАХ!!! ИСПОЛЬЗОВАТЬ ДРУГИЕ МЕТОДЫ:
- Параметризованные запросы: 

```sql
select * from accounts where id = @id;
```
- Проверять/санитизировать строки
- Использовать спец. библиотеки для санитизации, запросов
- Хранимые процедуры

8. REST. Web API.

Что такое web-сервисы
Протоколы веб-сервисов
SOAP
REST
Преимущества REST
Когда использовать REST
Что такое RESTful
Client-Server
Stateless
Cache
Layered System
Code-On-Demand
Принципы единого интерфейса
HATEOAS с примером
Реализация REST
Идемпотентность
HTTP методы
REST vs SOAP
Информирование потребителя
Contract First
Code First
Безопасность – уязвимости
Безопасность – аутентификация
Алгоритм Token-Based
Недостатки контроля доступа к объектам
Небезопасная десериализация
Отсутствие проверок и ограничений
Недостатки управления API
REST API Best Practices
Введение в Web API
Приложение
Атрибуты
Тестирование
Статусы
Возвращаемое значение в ASP.NET Core
IActionResult
Content negotiation
Accept
xml - возвращаемое значение
Аутентификация – JWT
JWT – сервисы и конвеер
JWT – генерация токена
Swagger / OpenAPI
Обработка ошибок.

9. Микросервисная архитектура

Общее описание
Сравнение с монолитом
Проблемы монолита
Преимущества микросервисов
Принципы проектирования
High Cohesion (высокая сплоченность)
Autonomous (автономность)
Business Domain Centric (сфокусированность на конкретной бизнес-задаче)
Resilience (отказоустойчивость)
Observable (наблюдаемость)
Automation (автоматизируемость)
Минусы микросервисной архитектуры
Реализация архитектуры
Модули
Слабая связанность
Взаимодействие микросервисов
Взаимодействие в .Net
Слабая связанность
Отказоустойчивость
API Gateway
Легкая заменяемость
Наблюдаемость
Health Check
Логгирование
