# Вопросы по информатике

## Введение в ASP.NET Core

### Понятие фреймворка

Фреймворк - карскас, определяющий структуру ПО. Облегчает разработку и объединение различных программных компонентов.
Диктует правила построения архитектуры приложения

### Особенности фреймворков

Библиотека, в отличие от фреймворка, предоставляет функциональность и не влияет на архитектуру.

### ASP.NET Core

ASP.NET Core - свободно-распространяемый кроссплатформенный фреймворк для создания веб-приложений на платформе .NET с открытым исходным кодом.
Построен на новом веб-стеке, но при этом обладает высокой степенью совместимости с ASP.NET.
Совмещает несколько моделей разработки: базовый (минимальные необходимые требования - middleware, routing, configuration), MVC, Razor Pages (надстройка над MVC), WebAPI, Blazor

### Свойство кросс-платформенности. Преимущества

Кросс-платформенность позволяет создавать WORA приложения (write once run anywhere). Мы можем написать общий код, описывающий общую функциональность, а затем запускать его на разных машинах, на разных ОС и т.д. Преимущества:

- Уменьшение времени разработки
- Сокращение расходов
- Единая кодовая база
- Покрытие более широкой аудитории
- Одинаковый UI/UX

### Запуск и настройка приложения

Приложение запускается из Main. Через метод статического класса WebApplicationBuilder.CreateBuilder() мы получаем объект WebApplicationBuilder, в котором определяем настройки нашего приложения: конфигурация, логирование, окружение, зависимости и т.д.

Когда настройка завершена, создаем само приложение, вызывая метод Build(). Полученный объект - наше приложение, которое и нужно запустить.

### Запуск

WebApplicationBuilder builder = WebApplication.CreateBuilder();
WebApplication app = builder.Build();

### Паттерн Builder

Builder - один из порождающих паттернов GoF. Позволяет создавать крупные составные объекты. Хорошо работает с FluentAPI.

Пример, когда есть значения по умолчанию, а нам нужно создать объект, в котором изменяется только 1 аргумент в конструкторе.

### Program и StartUp, как с этим в .NET 6

В .NET 6 убрали необходимость в отдельном классе StartUp. Его 2 основных метода теперь можно реализовать прямо в методе Main (начиная с C# 10 (вроде), метод Main не нужно явно реализовывать). Теперь все можно сделать в 1 методе - сначала ConfigureServices, затем Configure.

### HostBuilder. WebApplicationBuilder

HostBulider - **общий** класс для построения хостов.

WebApplicationBuilder - класс для постоения хостов преимущественно **HTTP(S)**.

В кратце, HostBuilder создает IHost (для любых подключений), WepHostBuilder создает IWebHost (для веб серверов). IHost может быть каким-нибудь клиентом Postgres (он http не принимает), IWebHost - наш веб-сервер. По умолчанию, в шаблоне Web используем IWebHost с WebHostBuilder.CreateBuilder(args)

### Content & Web root path

ContentRootPath - путь до файлов самого приложения (dll, exe)

WebRootPath - путь до файлов, обрабатываемых запросами (wwwroot по умолчанию)

Оба: абсолютные (с корня), задаются в IWebHostEnvironment, для каждого свой FileProvider

### Окружения

Нужны для корректной работы, передачи важных переменных (строки подключения, пароли, кол-во подключений в пуле и т.д.). Источники задаются в ConfigurationManager объекта IWebHostBuilder. 

Значения окружения могут быть получены из:

- файлов (launchSettings.json, web.config)
- переменных окружения (ASPNETCORE_URLS)
- задаваться вручную (AddInMemoryCollection(IEnumarable\<KeyValuePair\>))

### launchSettings.json

Настройки приложения могут быть получены из файла. По умолчанию в папке проекта ищется файл launchSettings.json, в котором в формате json определены настройки для проекта. 

Также в зависимости от типа кружения (Production, Developement ...) могут быть загружены специфичные настройки. Спец. настройки указываются в файле launchSettings.{Environment}.json (launchSettings.Development.json). Указанные в них значения перетирают launchSettings.json (если присутствуют)

### Класс Startup (.NET Core 3.x/5)

До .NET 6 для настройки сервисов и пайплайна обрабоки использовался класс специальный класс (StartUp по умолчанию), в котором должны быть опеределны 2 метода - ConfigureServices, Configure. В первом методе добавлялись сервисы необходимые для функционирования, во втором настраивался порядок обработки запроса (Pipeline).

### Настройка приложения в .NET 6

Начиная с .NET 6 необходимость в этом классе ушла и все необходимые манипуляции можно произвести в основном методе Main. Сначала создаем Builder, его настраиваем. Затем вызываем Build(), получаем  объект WepApplication. В нем настраиваем конвеер обработки (UseRouting, UseAuthorization...). В конце вызываем Run().

### Dependency Inversion Principle

Идея такая - вам нужен не сам класс, а его функциональность. Нам нужен не человек, а что-то, что может перетаскать коробки, а это могут быть робот, человек, магия и т.д. В таком случае, мы определяем ЧТО нам нужно, выделяем это ЧТО-ТО в отдельный интерфейс, и на основе этого делаем реализацию.

> Мы должны зависеть от абстракции, а не от реализации

### Сервисы

Сервис (англ. Service - обслуживать) - это что-то, что выполняет какую-то функциональность. Например, шлет email, логирует и т.д. 

Хорошо согласуется с [Dependency Inversion Principle](#dependency-inversion-principle) - в конструктор передаем выделенные интерфейсы.

### Инъекция зависимостей (зачем)

Инъекция зависимостей - паттерн, при котором мы передаем не сами классы с реализацией, а их интерфейсы (см. [Depency Inversion](#dependency-inversion-principle)). 

Зачем:

- динамчески заменять реализацию (в зависимости в от состояния подключения либо в памяти, либо в файл, либо в бд сохранять изменения)
- для тестов (заменяем на моки, стабы, фейки)

### IoC контейнеры

IoC container (IoC - Inversion of Control) - контейнер (объект) содержащий в себе все необходимые сущности. Сам выстраивает граф зависимостей для создания, определяет что нужно и т.д. В ASP.NET Core из коробки есть свой, но можно заменить на другие (Autofac ...)

### Инъекция в Startup (.NET Core 3.x/5)

В .NET Core 3.x/5 должен быть метод StartUp, котором есть методы ConfigureServices, Configure (см. [Класс StartUp (.NET Core 3.x/5)](#класс-startup-net-core-3x5)). Иногда нам нужно определить в каком окружении мы исполняемся - тест или прод. В таком случае мы можем пробросить зависимости в конструктор (или сам метод (уточнить!)). Например, IWebHostEnvironment.

### Замена контейнера. Замена на autofac

Замена контейнера производится как обычная замена сервиса - только заменить дескриптор. 

Пример для Autofac:

```cs
var host = new WebHostBuilder()
        .UseKestrel()
        .ConfigureServices(services => services.AddAutofac()) // Здесь заменяем
        .UseContentRoot(Directory.GetCurrentDirectory())
        .UseIISIntegration()
        .UseStartup<Startup>()
        .Build();

    host.Run();
```

Замена работает и для общего хоста IHost:

```cs
var host = Host.CreateDefaultBuilder(args)
        .UseServiceProviderFactory(new AutofacServiceProviderFactory())
        .ConfigureWebHostDefaults(webHostBuilder => {
          webHostBuilder
            .UseContentRoot(Directory.GetCurrentDirectory())
            .UseIISIntegration()
            .UseStartup<Startup>();
        })
        .Build();

    host.Run();
```

### Доступ к сервисам

Доступ к сервисам происходит:

- Автоматически с помощью DI контейнера через внедрение зависимосетей(конструктор, свойства(не рекомендуется), аргументы методов(new!!!!))
- Внедрить DI контейнер напрямую и разрешать самому

```cs
var service = _container.GetRequiredService<ISomeService>();
```

### Middleware

Middleware - ПО промежуточного слоя. Выстраивается в виде обработчика на конвеере запроса. Алгоритм такой:

1. Получаю запрос
2. Что-то с ним делаю
3. Решаю пускать ли его дальше или нет
4. Пускаю или возвращаю
5. Если пускаю, то могу обработать его еще раз на обратном пути

Настраивается после метода Build()/в методе Configure класса StartUp.
Для настройки используются методы Map, Use, Run

[Docs](https://docs.microsoft.com/ru-ru/aspnet/core/fundamentals/middleware/?view=aspnetcore-6.0)

### Методы Use и Run

Use:

- Метод расширения
- Создание цепочки обработки
- Принимает Func\<HttpContext, RequestDelegate, Task\>: (context, next) -> Task

Run:

- Конечная точка обработки
- Принимает RequestDelegate: (context) -> Task
- Если ничего не передавать - запускает приложение

### Методы Map и MapWhen

[Даже название не изменил](https://metanit.com/sharp/aspnet5/2.22.php)

Map:

- Сопоставляет путь с текущим и если совпал то переходит по требуемому пути исполнения
- Получает строку для сопоставления и builder (т.е. для каждого совпадения отдельный конвеер обработки)

MapWhen:

- Как Map, но с условием

### Создание компонент middleware

Создание:

- Middleware - класс с методом InvokeAsync(HttpContext context, RequestDelegate next)
- Есть интерфейс IMiddleware (не обязательно)
- Добавление в пайплайн - UseMiddleware\<TMiddleware\>()
- Можно создать свои кастомные UseXXX

### Статические файлы

Для обработки статических файлов есть middleware UseStaticFiles. Файлы ищутся по пути WebRootPath из объекта WebHostEnvironment.

### Конвейер обработки запроса

Последовательно добавляем свои Middleware в конвеер. При старте конвеер собирается, а при получении запроса передается в конвеер. Каждый middleware при получении решает что с ним делать: добавляет в ответ какие-то данные, проверяет заголовки, логирует и т.д. Дальше запрос может не передать (UseAuthentication, UseStaticFiles). Последний в конвеере из Use - Run. Он дальше не передает - конечная точка. 
Также для MVC есть свой отдельный пайплайн из фильтров: ResourceFilter, ExceptionFilter, AuthrizationFilter и другие.

### Время жизни middleware

Middleware живет все время существования приложения - singleton.
Поэтому, для внедрения зависимостей transient, scoped лучше использовать внедрение через метод.

### Ведение журнала

Поддержка логирования - встроенная. Для этого есть даже отдельное свойство - Logging.
Логирование может осуществляться во множество путей: файл, консоль, даже сеть.
Есть поддержка уровней логирования:

- None - не логировать
- Debug - для дебага (например, занчения переменных)
- Trace - для трассировки выполнения (например, отслеживать какой метод вызвался)
- Information - главная логика приложения (например, что заказ выполнен, пользователь зарегистрировался)
- Warning - ошибки, не влияющие на выполнение приложения (например, отправка email не работает)
- Error - ошибки, которые влияют на корректное исполнение приложения и должны быть обработаны (например, бд недоступна)
- Critical - пиздец (например, переполнение бд, недостаток памяти)

Для логирования есть метод Log() и его расширения LogInformation и т.д.

Интерполяцию лучше не делать, а передавать аргументы позже (т.к. интерполяция стоит время, а если просто передавать аргументы, то она отложенная)

### Обработка ошибок

Ошибки есть 2 типов - сервера и логики (Exceptions и те, что должны вернуть HTTP 4xx статус).
Если это 2 - то, все ок возвращаем статус (+ страница если нужно).

Если это 1 - то, все плохо. Разработчик, должен понять, что произошло (UseDeveloperExceptionPage), а пользователь не должен такое увидеть (UseExceptionHandler)

В обоих случаях нужно логировать.

### Публикация в Azure

На Azure публикация проста - в Visual Studio кликаем на Publish, выбираем Azure, вводим свои данные, план, место и т.д. и публикуем. (Он вроде сам там скомпилирует(проверить!!))

## ASP.NET Core. Publish & Deploy

## Модель хостинга ASP.NET Core


Reverse proxy
Run ASP.NET Core app
Публикация
Запуск опубликованного приложения
dotnet command
Независимый деплой
Как деплоить
CI
CD
Развёртывание в IIS
Пул приложений
Поддержка в коде
Middleware
web.config
Хостинг приложений под Linux
Run ASP.NET Core app on Linux
app & reverse proxy on different servers
ASP.NET Core in Docker
Docker
Потенциальные проблемы при деплое
Разница между Linux и Windows
Конфигурирование
Бандлинг/минификация

3. ASP.NET Core. Middleware

Обработка запроса
HttpContext
HttpRequest
HttpResponse
Middleware
Примеры
Middleware Pipeline
Выстраивание конвейера
Методы Use, Map, Run, MapWhen
Проблема с формированием ответа
Кастомные компоненты Middleware
Дополнительные параметры
Порядок вызова
Middleware обработки ошибок
Middleware vs Services
Маршрутизация в ASP.NET Core
Конечные точки
Шаблоны маршрутов
Маршрутизация - Концепции
Совпадение маршрутов
Генерация URL-адресов
Обработка ошибок
Обработка ошибок HTTP: UseStatusCodePagesWithRedirects vs UseStatusCodePagesWithReExecute
Использование Cookie
Сессии

4. ASP.NET Core. Services & DI

Сервисы - зависимости
Пример зависимости
Проблемы прямых зависимостей
S.O.L.I.D
ServiceLocator
DI анти-паттерны
IoC (Inversion of Control)
Свой тривиальный контейнер
IServiceProvider
Регистрация сервисов
IServiceCollection Extension methods
Время жизни
Варианты регистрации
Общая схема работы
Типичные ошибки с Lifetime
Резолв из transient сервиса scoped или singleton зависимостей
GetService<TService>()
Несколько сервисов или интерфейсов
Рекомендации по созданию сервисов
Disposal of services
Рекомендации по использованию сервисов

5. Архитектура приложений ASP.NET Core MVC

Монолитное приложение
All-in-one приложения
Слои приложения
Правильные зависимости
Чистая архитектура
Распределение по слоям
Ядро приложения - Бизнес-логика
Типы данных ядра приложения
Инфраструктура - Доступ к данным
Типы данных слоя инфраструктуры
Repository pattern
Generic Repository
Инъекция Repository
Unit of Work
Repository и UoW в .NET
Уровень пользовательского интерфейса
Типы данных UI
UI ASP.NET Core
ASP.NET Core MVC / Razor Pages
Model / ViewModel
Контроллеры
Действия (action)
IActionResult
IActionResult: redirect
Валидация модели
Представления
Razor
Передача данных в представления
Вспомогательные функции тегов
Скаффолдинг
Маршрутизация
Атрибуты маршрутизации
ControllerContext
Передача параметров в запросе
model binding, массивы/объекты
Загрузка файлов
Работа с файлами - Безопасность
Инъекции зависимостей

6. ASP.NET Core Auth*

Фильтры MVC
Виды фильтров
Создание фильтров
Добавление фильтров
Identification / Authentication / Authorization
Способы аутентификации
По сертификатам
По одноразовым паролям
По ключам доступа
Аутентификации по паролю
HTTP authentication
Forms authentication
URL query
Request body (POST, PUT, PATCH)
HTTP header
Аутентификация по паролю - Уязвимости
Аутентификация по токенам
Форматы токенов
Аутентификация в ASP.NET Core
HttpContext.User
ClaimsPrincipal
Claims vs Roles approach
Процесс аутентификации
Middleware
Добавление в обработку
Задачи аутентификации
Схема аутентификация
Создание аутентификационной куки
Удадение и обновление куки
ASP.Net Core Identity
Возможности Identity
Кастомизация Identity
Сервисы Identity
Настройка Cookie для Identity
Identity’s database schema
Сервисы
Кастомизация пользователей
Кастомные claims
Simple Authorization
Авторизация по ролям
Authorization Policy
Добавление политики авторизации
Ограничения политик (методы)
RequireAssertion(handler)
Пример авторизации
Пример своего ограничения
Обработчик своего ограничения
Регистрация своего ограничения
Использование контекста MVC
Resource-based authorization
Включение в представления.

7. ASP.NET Core. Security

SSL
Сертификаты
Атака Open Redirect
Защита
Защита данных
Шифрование данных (CryptoAPI)
Установка времени жизни
Хранение паролей
Настройка криптографии
Клиентские уязвимости
Same-origin policy (SOP)
Что такое Origin
Суть XSS
Примеры XSS
Как предотвратить инъекции
Валидация и фильтрация
Санитизация
Общие правила
Razor
Валидация и санитизация
Content Security Policy (CSP)
CSP Report Request
Тег base
X-XSS-Protection
Cross-Site Request Forgery (CSRF)
Double-Submit Cookie Pattern
Валидация Anti Forgery Token
Anti Forgery Token в AJAX, WebAPI, SPA
Cross Origin Request Sharing (CORS)
Безопасность кук
Достаточно ли HttpOnly? SQL-инъекции.

8. REST. Web API.

Что такое web-сервисы
Протоколы веб-сервисов
SOAP
REST
Преимущества REST
Когда использовать REST
Что такое RESTful
Client-Server
Stateless
Cache
Layered System
Code-On-Demand
Принципы единого интерфейса
HATEOAS с примером
Реализация REST
Идемпотентность
HTTP методы
REST vs SOAP
Информирование потребителя
Contract First
Code First
Безопасность – уязвимости
Безопасность – аутентификация
Алгоритм Token-Based
Недостатки контроля доступа к объектам
Небезопасная десериализация
Отсутствие проверок и ограничений
Недостатки управления API
REST API Best Practices
Введение в Web API
Приложение
Атрибуты
Тестирование
Статусы
Возвращаемое значение в ASP.NET Core
IActionResult
Content negotiation
Accept
xml - возвращаемое значение
Аутентификация – JWT
JWT – сервисы и конвеер
JWT – генерация токена
Swagger / OpenAPI
Обработка ошибок.

9. Микросервисная архитектура

Общее описание
Сравнение с монолитом
Проблемы монолита
Преимущества микросервисов
Принципы проектирования
High Cohesion (высокая сплоченность)
Autonomous (автономность)
Business Domain Centric (сфокусированность на конкретной бизнес-задаче)
Resilience (отказоустойчивость)
Observable (наблюдаемость)
Automation (автоматизируемость)
Минусы микросервисной архитектуры
Реализация архитектуры
Модули
Слабая связанность
Взаимодействие микросервисов
Взаимодействие в .Net
Слабая связанность
Отказоустойчивость
API Gateway
Легкая заменяемость
Наблюдаемость
Health Check
Логгирование
